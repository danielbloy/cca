{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Hello and welcome! Why have I started this site? I run a Code Club in a library in rural Norfolk in the UK which I thoroughly love. One of the biggest challenges I've found is in having suitable materials for the children to work through; particularly when delivering the sessions on library computers that are completeley locked down (and old). All of the lessons I deliver are done using tools that can be run in a browser on a relatively low specification computer. Also, the materials and tools I use are free to minimise costs.</p> <p>Even though there are plenty of materials out there, they are often hard to find in the ocean of the world wide web. I have also found that some platforms are better supported than others and the quality of materials available varies a lot.</p> <p>This site is a curated list of quality materials from other sources that I use in my sessions and some that I have produced myself to help you on your coding journey. The materials are presented in a structured pathway to help you develop your skills in a progressive way.</p> <p>My recommended pathways are:</p> <ul> <li>Beginning (Blocks)</li> <li>Progressing (Python)</li> <li>Advancing (CircuitPython)</li> </ul>"},{"location":"#beginning-blocks","title":"Beginning (Blocks)","text":"<p>Start with Blocks based programming such as Scratch and MakeCode Arcade. This provides the easiest transition into coding as it is very visual and interactive allowing you to develop your skills.</p> <p>As your skills develop, you can also explore the BBC micro:bit which offers blocks based programming and even MakeCode Mindstorms.</p>"},{"location":"#progressing-python","title":"Progressing (Python)","text":"<p>As your programs become more advanced, blocks based programming can become more challenging to use. At this point you will want to transition from blocks to text based programming. The best language to use to make this transition is Python.</p> <p>Whilst Python is not supported on the Scratch platform, it is supported on the MakeCode Arcade, MakeCode Mindstorms and BBC micro:bit platforms as well as the Replit IDE.</p>"},{"location":"#advancing-circuitpython","title":"Advancing (CircuitPython)","text":"<p>Now is time to move onto the Raspberry Pi Pico with CircuitPython! This takes you on a journey of physical computing where you write Python code to control microprocessors. To give you a flavour of what can be done with CircuitPython (or its cousin MicroPython) take a look at these short YouTube videos of the Halloween 2023 project and Halloween 2024 project projects which my daughter and I worked on. You can read more about that adventure and see some other projects we've worked on at Coding Clubs by heading over to my GitHub project pages  pico-interactive-halloween and pico-interactive.</p> <p>Don't be scared by any complex looking electronics. Getting started with CircuitPython or MicroPython is super easy and there are plenty of guides available. For some great places to start, take a look at the my CircuitPython links.</p>"},{"location":"blocks/","title":"Blocks","text":"<p>Beginners should start their coding journey with Scratch and then progress on to MakeCode Arcade.</p>"},{"location":"blocks/#scratch","title":"Scratch","text":"<p>The scratch sessions in my Code Club are built around the materials provided by Code Club. I recommend working through the activities in order. Depending on experience, each activity will take between 45 and 90 minutes.</p>"},{"location":"blocks/#module-1-link","title":"Module 1 (link)","text":"<p>1 - Rock band</p> <p>2 - Lost in space</p> <p>3 - Ghostbusters</p> <p>4 - Chatbot</p> <p>5 - Paint box</p> <p>6 - Boat race</p>"},{"location":"blocks/#module-2-link","title":"Module 2 (link)","text":"<p>1 - Memory</p> <p>2 - Dodgeball</p> <p>3 - Brain game</p> <p>4 - Catch the dots</p> <p>5 - Clone wars</p> <p>6 - Create your own world</p>"},{"location":"blocks/#module-3-link","title":"Module 3 (link)","text":"<p>1 - CATS!</p> <p>2 - Flower generator</p> <p>3 - Guess the flag</p> <p>4 - Line up</p> <p>5 - Flappy parrot</p> <p>6 - Binary hero</p>"},{"location":"blocks/#makecode-arcade","title":"MakeCode Arcade","text":"<p>All of the following MakeCode Arcade materials are those that I have written (often hurriedly) for my own Code Club. Most of the materials need updating as the available blocks have changed but they should still be useful as the basis for a lesson. Most will take between 30 and 60 minutes to make. I will be reworking each of these as well as adding new materials over the coming months. The materials are marked as alpha, beta or final based on the quality/stage of development of the material. The alpha materials will be first stage PDFs, beta are updated web based materials but not neccessarily battle tested in the Coding Club yet so may contain errors and final will be the tested materials.</p>"},{"location":"blocks/#stage-1-basic-blocks","title":"Stage 1 - Basic Blocks","text":"<p>1 - Chase, alpha</p> <p>2 - Catch, alpha</p> <p>3 - Smash, alpha</p> <p>4 - Jump, coming</p>"},{"location":"blocks/#stage-2-advanced-blocks","title":"Stage 2 - Advanced Blocks","text":"<p>1 - Blaster, alpha</p> <p>2 - Worm, alpha</p> <p>3 - Burger Blast, alpha</p> <p>4 - Invaders, alpha</p> <p>5 - Treasure, coming</p> <p>6 - Memory, alpha</p> <p>7 - Mouse, coming</p>"},{"location":"blocks/#stage-3-self-directed-learning","title":"Stage 3 - Self Directed Learning","text":"<p>1 - Invasion of the Alien Ducks, final (errata)</p>"},{"location":"blocks/#published-works","title":"Published works","text":""},{"location":"blocks/#invasion-of-the-alien-ducks","title":"Invasion of the Alien Ducks","text":"<p>Errata for Invasion of the Alien Ducks.</p> <p>This is the first material that I've produced which is suitable for wide distribution. It's a MakeCode Arcade Blocks worksheet and is suitable for anyone that has some experience of blocks programming.</p> <p>The PDF is available here and is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</p> <p>To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/. The materials are designed to be used in printed form. As this is over 40 pages long and image heavy, I have published it on Amazon where you can buy a printed copy for \u00a34.50.</p>"},{"location":"contact/","title":"Contact","text":"<p>I'd love to hear your feedback. Please feel free to contact me via e-mail at daniel.bloy@codeclubadventures.com.</p>"},{"location":"errata/","title":"Errata for Invasion of the Alien Ducks","text":"<p>Step 6 - Creating a function to descend sprites.</p> <p>After completing step 6, shooting a Duck or Apple that is on the top row will result in the \"Program Error: sim error: failed to cast on null\" being reported. The cause is due to the placement of the final 4 blocks in the outer if block highlighted in the below screen shot.</p> <p></p> <p>The blocks need moving into the inner if block as shown in this screen shot.</p> <p></p>"},{"location":"license/","title":"License","text":"<p>All materials provided on this site is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/.</p> <p>In summary, this means that you are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format.</li> <li>Adapt \u2014 remix, transform, and build upon the material.</li> </ul> <p>Provided you follow these terms:</p> <ul> <li>Attribution \u2014 You must give appropriate credit , provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> </ul>"},{"location":"links/","title":"Links","text":"<p>The following are a collection of my favourite tools/sites:</p>"},{"location":"links/#general","title":"General","text":"<ul> <li>Code Club.</li> <li>CoderDojo.</li> <li>MultiWingSpan contains lots of coding examples.</li> </ul>"},{"location":"links/#retail","title":"Retail","text":"<ul> <li>Pimoroni who sell all the amazing electronics devices used in our code clubs as well as designing some amazing stuff.</li> <li>The PiHut who sell all things Raspberry Pi and other amazing electronics kits.</li> <li>Cool Component who sell electronics and a range of other goodies.</li> <li>Kitronik who are a specialist in electronic project kits.</li> </ul>"},{"location":"links/#books","title":"Books","text":"<ul> <li>Python in easy steps provides an excellent introduction to Python and is used as the reference book in my Python challenges.</li> <li>Invent Your Own Computer Games with Python by Al Sweigart (available free online or in print from Amazon).</li> <li>Python Programming Exercises, Gently Explained by Al Sweigart (available free online or in print from Amazon).</li> <li>Making Games with Python &amp; Pygame by Al Sweigart (available free online or in print from Amazon).</li> <li>The Big Book of Small Python Projects by Al Sweigart (available free online or in print from Amazon).</li> </ul>"},{"location":"links/#blocks","title":"Blocks","text":"<ul> <li>Scratch for coding Scratch games and applications.</li> <li>MakeCode Arcade for coding MakeCode Arcade games.</li> <li>MakeCode micro:bit</li> <li>MakeCode Mindstorms.</li> </ul>"},{"location":"links/#online-ides-and-editors","title":"Online IDEs and Editors","text":"<ul> <li>Replit who provide a full web based IDE for Python and many other languages.</li> </ul>"},{"location":"links/#online-art-tools-and-assets","title":"Online art tools and assets","text":"<ul> <li>PixilArt is an online paint program that is easy to use and supports transparency.</li> <li>Piskel is a free online editor for animated sprites &amp; pixel art.</li> <li>Pixlr is a free online photo editor.</li> <li>Vectr is a free online vector graphics editor.</li> <li>Kenney free game art assets.</li> <li>OpenGameArt.org free game art assets.</li> </ul>"},{"location":"links/#python","title":"Python","text":"<ul> <li>Invent With Python is a collection of wonderful books written by Al Sweigart and available free online.</li> <li>MicroPython</li> <li>CircuitPython which is a fork of MicroPython by AdaFruit and aimed as a beginner friendly version. See below for more links.</li> <li>MakeCode Maker which offers blocks, JavaScript and Python based coding of microcontrollers.</li> <li>Python micro:bit.</li> <li>Pygame Zero is a framework for creating games without boilerplate.</li> <li>Pygame Zero Helper is a Python module that provides a range of functions to make it easier to write Pygame Zero games. It has a particularly rich set of collision detection helper functions.</li> <li>GuiZero is designed to allow learners to quickly and easily create Graphical User Interfaces for their programs.</li> </ul>"},{"location":"links/#circuitpython","title":"CircuitPython","text":"<ul> <li>Learn CircuitPython.</li> <li>Overview.</li> <li>Essentials.</li> <li>AsyncIO.</li> <li>Libraries bundle.</li> <li>Libraries bundle docs.</li> <li>Using a PC.</li> </ul>"},{"location":"links/#bbc-microbit","title":"BBC micro:bit","text":"<ul> <li>BBC micro:bit.</li> <li>MakeCode micro:bit.</li> <li>Python micro:bit.</li> </ul>"},{"location":"links/#lego-mindstorms","title":"Lego Mindstorms","text":"<ul> <li>MakeCode Mindstorms.</li> <li>MakeCode Mindstorms documentation.</li> </ul>"},{"location":"python/","title":"Python","text":"<p>To avoid having to setup a local Python development environment, a good way to get started with Python is to use an online IDE. These can be used from pretty much any device including Windows PCs, Macs, Linux, Raspberry Pi, Android tablets or iPads. At my Code Club I use Replit which has a free tier. See the Replit guide to get started.</p> <p>MakeCode Arcade also allows you to write your games in Python.</p>"},{"location":"python/#books","title":"Books","text":"<p>There are a huge range of resources out there for Learning Python and it can be daunting for beginners to identify which are worth their investment in time or money. I recommend the following resources:</p> <p>Python in easy steps is a concise and low cost overview of the language and the book I use with my learners during Python sessions. The Python challenges I have written contain  references to the relevant sections in this book.</p> <p>The following books are all written by Al Sweigart and available free on his website https://inventwithpython.com. Print versions are available direct from the publisher or Amazon for a fee. There are a range of books covering several topics and 4 that I recommend for Python are:</p> <p>Invent Your Own Computer Games with Python</p> <p>Python Programming Exercises, Gently Explained</p> <p>Making Games with Python &amp; Pygame</p> <p>The Big Book of Small Python Projects</p>"},{"location":"python/#code-club-python","title":"Code Club Python","text":""},{"location":"python/#module-1","title":"Module 1","text":"<p>1 - About Me</p> <p>2 - Rock, Paper, Scissors</p> <p>3 - Turtle race</p> <p>4 - Team Chooser</p> <p>5 - Colourful Creations</p> <p>6 - Secret Messages</p>"},{"location":"python/#module-2","title":"Module 2","text":"<p>1 - Modern Art</p> <p>2 - Popular pets</p> <p>3 - RPG</p> <p>4 - Where is the Space Station</p> <p>5 - Robo-Trumps</p> <p>6 - CodeCraft</p>"},{"location":"python/#al-sweigart-python","title":"Al Sweigart Python","text":"<p>These projects are a curated list of projects and exercises from the 4 Al Sweigart books listed at the top of this page. The materials are excellent and have been generously made freely available online. If you find them useful and use them, please consider supporting Als generosity by purchasing his books or donating on his website here. Each of the modules below contains some exercises, projects and games. It is recommended that you have already completed Code Club Python before starting these.</p>"},{"location":"python/#module-1_1","title":"Module 1","text":"<p>1 - Project: #15 Deep Cave, The Big Book of Small Python Projects, Al Sweigart</p> <p>2 - Project: #3 Bitmap Message, The Big Book of Small Python Projects, Al Sweigart</p> <p>3 - Project: #2 Birthday Paradox, The Big Book of Small Python Projects, Al Sweigart</p> <p>4 - Exercise: #2 Temperature Conversion, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>5 - Exercise: #3 Odd &amp; Even, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>6 - Game: Tic-Tac-Toe, Invent Your Own Computer Games with Python, Al Sweigart</p>"},{"location":"python/#module-2_1","title":"Module 2","text":"<p>1 - Project: #10 Cho-Han, The Big Book of Small Python Projects, Al Sweigart</p> <p>2 - Project: #7 Caesar Hacker, The Big Book of Small Python Projects, Al Sweigart</p> <p>3 - Project: #5 Bouncing DVD Logo, The Big Book of Small Python Projects, Al Sweigart</p> <p>4 - Exercise: #4 Area &amp; Volume, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>5 - Exercise: #5 Fizz Buzz, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>6 - Game: Sonar Treasure Hunt, Invent Your Own Computer Games with Python, Al Sweigart</p>"},{"location":"python/#module-3","title":"Module 3","text":"<p>1 - Project: #8 Calendar Maker, The Big Book of Small Python Projects, Al Sweigart</p> <p>2 - Project: #9 Carrot in a Box, The Big Book of Small Python Projects, Al Sweigart</p> <p>3 - Project: #13 Conways Game of Life, The Big Book of Small Python Projects, Al Sweigart</p> <p>4 - Exercise: #9 Chess Square Colour, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>5 - Exercise: #10 Find and Replace, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>6 - Game: The Reversegam Game, Invent Your Own Computer Games with Python, Al Sweigart</p>"},{"location":"python/#module-4","title":"Module 4","text":"<p>1 - Project: #12 Collatz Sequence, The Big Book of Small Python Projects, Al Sweigart</p> <p>2 - Project: #1 Bagels, The Big Book of Small Python Projects, Al Sweigart</p> <p>3 - Project: #17 Dice Math, The Big Book of Small Python Projects, Al Sweigart</p> <p>4 - Exercise: #11 Hours, Minutes, Seconds, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>5 - Exercise: #12 Smallest and Biggest, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>6 - Game: Memory Puzzle, Making Games with Python &amp; Pygame, Al Sweigart</p>"},{"location":"python/#module-5","title":"Module 5","text":"<p>1 - Project: #14 Countdown, The Big Book of Small Python Projects, Al Sweigart</p> <p>2 - Project: #11 Clickbait, The Big Book of Small Python Projects, Al Sweigart</p> <p>3 - Project: #4 Blackjack, The Big Book of Small Python Projects, Al Sweigart</p> <p>4 - Exercise: #14 Average, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>5 - Exercise: #17 Dice Roll, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>6 - Game: Wormy, Making Games with Python &amp; Pygame, Al Sweigart</p>"},{"location":"python/#module-6","title":"Module 6","text":"<p>1 - Project: #16 Diamonds, The Big Book of Small Python Projects, Al Sweigart</p> <p>2 - Project: #18 Dice Roller, The Big Book of Small Python Projects, Al Sweigart</p> <p>3 - Project: #22 Ducklings, The Big Book of Small Python Projects, Al Sweigart</p> <p>4 - Exercise: #18 Buy 8 Get 1 Free, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>5 - Exercise: #19 Password Generator, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>6 - Game: Simulate, Making Games with Python &amp; Pygame, Al Sweigart</p>"},{"location":"python/#module-7","title":"Module 7","text":"<p>1 - Project: #19 Digital Clock, The Big Book of Small Python Projects, Al Sweigart</p> <p>2 - Project: #21 DNA Visualisation, The Big Book of Small Python Projects, Al Sweigart</p> <p>3 - Project: #27 Fish Tank, The Big Book of Small Python Projects, Al Sweigart</p> <p>4 - Exercise: #25 Multiplication Table, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>5 - Exercise: #27 Rectangle Drawing, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>6 - Game: Tetromino, Making Games with Python &amp; Pygame, Al Sweigart</p>"},{"location":"python/#module-8","title":"Module 8","text":"<p>1 - Project: #20 Digital Stream, The Big Book of Small Python Projects, Al Sweigart</p> <p>2 - Project: #23 Etching Drawer, The Big Book of Small Python Projects, Al Sweigart</p> <p>3 - Project: #28 Flooder, The Big Book of Small Python Projects, Al Sweigart</p> <p>4 - Exercise: #23 99 Bottles of Beer, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>5 - Exercise: #38 Random Shuffle, Python Programming Exercises, Gently Explained, Al Sweigart</p> <p>6 - Game: Star Pusher, Making Games with Python &amp; Pygame, Al Sweigart</p>"},{"location":"python/#challenges","title":"Challenges","text":"<p>The following materials are designed for self-directed learning once comfortable with writing Python scripts. I recommend only starting the challenges once you have completed Modules 1 and 2 above. Each of the challenges contain references to the book Python in easy steps and I recommend purchasing a copy (though it is not essential).</p> <p>1 - Guess the number</p> <p>2 - Higher or lower</p>"},{"location":"python/#coding-games-with-pygame-zero-python","title":"Coding Games with Pygame Zero &amp; Python","text":"<p>The following materials are provided freely online by Richard Smith and take the reader from the fundamentals of Python to writing games using Pygame Zero. The website is available here.</p>"},{"location":"python/#fundamentals","title":"Fundamentals","text":"<p>4 - Drawing graphics</p> <p>5 - Arcade games</p> <p>6 - Improving your games</p> <p>7 - More advanced games</p>"},{"location":"python/#tutorials","title":"Tutorials","text":"<p>8 - Tutorial: Chase game</p> <p>9 - Tutorial: Maze game</p> <p>10 - Tutorial: Shooting game</p> <p>11 - Tutorial: Race game</p>"},{"location":"python/#more-games-with-pygame-zero","title":"More Games with Pygame Zero","text":"<p>I have written the following Pygame materials which are designed to be followed after working through the Code Club Python materials. The reader should have a moderate grasp of Python. All of these materials have been designed to work with the online programming IDE Replit.</p>"},{"location":"python/#module-1-building-foundations","title":"Module 1 - Building foundations","text":"<p>1 - Muncher (Pac-Man), beta</p> <p>2 - Smash (Breakout), beta</p> <p>2a - List comprehensions</p> <p>2b - Classes and inheritance, coming</p> <p>3 - Memory (Simon Says), coming</p> <p>4 - Pairs, coming</p> <p>5 - Bugs (Whac-A-Mole), coming</p> <p>5b - Improving collision detection, coming</p> <p>6 - Aliens (Galaxian), coming</p>"},{"location":"python/#module-2-expanding-techniques","title":"Module 2 - Expanding techniques","text":"<p>1 - Paint, coming</p> <p>2 - Stack (Tetris), coming</p> <p>3 - Rocks (Missile Command), coming</p> <p>4 - Fireworks, coming</p> <p>5 - Jumper (Mario Bros), coming</p> <p>6 - Toad (Frogger), coming</p>"},{"location":"python/#tranche-3-pushing-boundaries","title":"Tranche 3 - Pushing boundaries","text":"<p>1 - OXO, coming</p> <p>2 - Race (Outrun), coming</p> <p>3 - Sandwiches (Burger Time), coming</p> <p>4 - Invaders (Space Invaders), coming</p> <p>5 - Collision (Geometry Wars/Asteroids), coming</p> <p>6 - Concrete (Cement Factory), coming</p>"},{"location":"python/#makecode-arcade-python","title":"MakeCode Arcade Python","text":"<p>MakeCode Arcade also allows you to write your games in Python (though it is more limited than Replit and not as mature as the MakeCode Arcade TypeScript tooling). The materials that I initially produced highlighted some issues with the early access Python tooling so we stopped using it. In time, I'm sure the tooling will mature enough for us to use it again. The materials are marked as alpha, beta or final based on the quality/stage of development of the material. The alpha materials will be first stage PDFs, beta are updated web based materials but not neccessarily battle tested in the Coding Club yet so may contain errors and final will be the tested materials.</p> <p>1 - OXO, alpha</p> <p>2 - Invaders, alpha</p> <p>3 - Smash, alpha</p> <p>4 - Frog, coming</p> <p>5 - Muncher, coming</p>"},{"location":"replit/","title":"Replit","text":"<p>In my Code Clubs, I use Replit for the intermediate and more advanced programming provides as it provides a full web based IDE for Python and many other languages; it allso offers a free tier.</p>"},{"location":"replit/#getting-started","title":"Getting started","text":"<p>Coming...</p>"},{"location":"replit/#replit-education","title":"Replit Education","text":"<p>Sadly, this is being deprecated so can no longer be used.</p>"},{"location":"replit/#public-vs-private-repositories","title":"Public vs. Private repositories","text":"<p>Coming...</p>"},{"location":"replit/#create-a-new-python-program","title":"Create a new Python program","text":"<p>Coming...</p>"},{"location":"replit/#create-a-new-pygame-zero-program","title":"Create a new PyGame Zero program","text":"<p>Coming...</p>"},{"location":"python/challenges/guess_the_number/","title":"Guess the Number","text":""},{"location":"python/challenges/guess_the_number/#challenge","title":"Challenge","text":"<p>Your aim is to follow the steps and use the hints to create a text-based game where the player must try and guess a number between 1 and 10 that is randomly chosen by the computer, in as few guesses as possible. Test your game each time you make a change by running it.</p> <p>Page numbers are provided for the book Python in easy steps (PIES) by Mike McGrath</p>"},{"location":"python/challenges/guess_the_number/#steps","title":"Steps","text":"<ol> <li> <p>Output a welcome message to the player to guess a number between 1 and 10.</p> <p>Use the <code>print()</code> function. PIES: Pages 16 to 17.</p> </li> <li> <p>Randomly generate an integer number between 1 and 10.</p> <p>Use the <code>random.random()</code> and <code>int()</code> functions. PIES: Pages 170 to 171.</p> <p>Alternatively, use Google to find out about the <code>random.randint()</code> function.</p> </li> <li> <p>Let the players make a single guess.</p> <p>Get the players guess with the <code>input()</code> function and save it to a variable. PIES: Pages 18 to 21.</p> <p>Convert the players guess to a number using the <code>int()</code> function. PIES: Page 170.</p> <p>Compare to the random number to the players guess and inform them if the number is too high,  too low, or correct using the <code>if</code> statement and <code>&gt;</code> and <code>&lt;</code> operators. PIES: Pages 52, 53 and 30, 31.</p> </li> <li> <p>Count how many guesses the player takes to guess correctly.</p> <p>Use a variable to track the number of guesses made. PIES: Pages 18 and 19.</p> <p>Use a while loop to allow the player to guess until correct. PIES: Pages 54 to 55.</p> </li> <li> <p>Ask the player if they want to play again?</p> <p>Extract out your main game look into a function using <code>def</code>. PIES: Pages 62 to 63.</p> <p>Make your new function return the number of guesses made. PIES: Pages 66 to 67.</p> <p>Ask the player if they want to play another game by entering Y or N; use the <code>input()</code> function.</p> <p>PIES: Pages 18 to 21.</p> </li> <li> <p>Track the fewest guesses to guess correctly.</p> <p>Use a variable to keep track of the fewest guesses made so far.</p> <p>Congratulate the player if they play a game and require fewer guesses than the previous best.</p> </li> <li> <p>Ask the player what the upper limit for the game should be rather than 10.</p> <p>Presently your game asks the player to guess a number from 1 to 10. Adjust your game so it first asks the player what the upper limit should be so that they can play a harder or easier game.</p> </li> </ol> <p>Once you've done this, how many guesses does it take you to guess a random number from 1 to 100? How about 1 to 1,000?</p>"},{"location":"python/challenges/guess_the_number/#solution","title":"Solution","text":"<p>Download a sample solution here.</p>"},{"location":"python/challenges/guess_the_number/#pdf","title":"PDF","text":"<p>Download this challenge as a PDF file.</p>"},{"location":"python/challenges/higher_or_lower/","title":"Higher or lower","text":""},{"location":"python/challenges/higher_or_lower/#challenge","title":"Challenge","text":"<p>Your aim is to follow the steps and use the hints to create a text-based game where the computer generates 10 random numbers between 1 and 50. The player is shown the first number and must then guess if the next number is higher or lower. If the player guesses correctly, they then try to guess if the next number is higher or lower. This continues until the player guesses correctly 9 times or guesses incorrectly. Test your game each time you make a change by running it.</p> <p>Page numbers are provided for the book Python in easy steps (PIES) by Mike McGrath</p>"},{"location":"python/challenges/higher_or_lower/#steps","title":"Steps","text":"<ol> <li> <p>Output a message to the player informing them of the instructions for the game.</p> <p>Use the <code>print()</code> function. PIES: Pages 16 to 17.</p> </li> <li> <p>Randomly generate 10 integers between 1 and 50 and add them to a list variable. Make sure that no two consecutive numbers are the same.</p> <p>Use a variable to record the list of numbers generated. PIES: Pages 18 to 19 and 44 to 47.</p> <p>Use the <code>random.random()</code> and <code>int()</code> functions. PIES: Pages 170 to 171.</p> <p>Alternatively, use Google to find out about the <code>random.randint()</code> function.</p> <p>Use an <code>if</code> statement and the inequality operator (<code>!=</code>) to ensure consecutive numbers have different values. PIES: Pages 52 to 53 and 30.</p> </li> <li> <p>Show the user the first number and ask them for higher or lower. The player should enter 'h' or 'H' for higher and 'l' or 'L' for lower. Keep prompting until the user enters the correct value.</p> <p>Get the players guess with the <code>input()</code> function and save it to a variable. PIES: Pages 18 to 21.</p> <p>Use a while loop to ask for input until a correct value is supplied. PIES: Pages 54 to 55.</p> </li> <li> <p>Compare the next value against the players decision and let them know if they were correct.</p> <p>Use the <code>if</code> and <code>elif</code> statements and <code>&gt;</code> and <code>&lt;</code> operators. PIES: Pages 52 to 53 and 30 to 31.</p> <p>You will need to index into the list using the <code>[</code> and <code>]</code> characters. PIES: Pages 44 to 45.</p> </li> <li> <p>Allow the player to keep guessing until they guess incorrectly or get to the end. Keep track of how many guesses the player makes.</p> <p>Use a variable to track the number of guesses made. PIES: Pages 18 to 19.</p> <p>Use a <code>while</code> loop to allow the player to guess until correct. PIES: Pages 54 to 55.</p> <p>Use <code>break</code> to exit the loop early. PIES: Pages 58 to 59.</p> </li> <li> <p>Once the game has ended, show the player the full set of random numbers.</p> </li> <li> <p>Ask the player if they want to play again? If they answer yes, then let them have another go.</p> </li> <li> <p>Keep track of the largest number of successful guesses and let the player know if they exceed it.</p> </li> </ol> <p>Once you've completed your game, how many correct guesses can you get in a row?</p>"},{"location":"python/challenges/higher_or_lower/#solution","title":"Solution","text":"<p>Download a sample solution here.</p>"},{"location":"python/challenges/higher_or_lower/#pdf","title":"PDF","text":"<p>Download this challenge as a PDF file.</p>"},{"location":"python/pygame/aliens/","title":"Aliens","text":"<p>These instructions will take you through the steps of creating a game that uses the 1979 game Galaxian and the 1981 game Galaga as its inspiration.</p> <p>TODO: Game summary</p>"},{"location":"python/pygame/aliens/#step-0-create-the-project-in-replit","title":"Step 0: Create the project in Replit","text":"<p>Navigate to Replit and login.</p> <p>Create a new project using the Pygame template and give it the title \"Aliens\" as illustrated by the screenshot below.</p> <p></p> <p>In the <code>main.py</code> file, replace the code provided with the code below and run the program to make sure it can download the packages and runs. You should be presented with a black screen with a red zero for the score at the top of the screen.</p> <pre><code>import time\nimport pgzrun\nimport types\n\nWIDTH = 640\nHEIGHT = 700\n\nscore = 0\nlives = 3\npaused = False\n\ndef draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\npgzrun.go()\n</code></pre>"},{"location":"python/pygame/bugs/","title":"Bugs","text":"<p>These instructions will take you through the steps of creating a game that uses the 1975 game Whac-A-Mole as its inspiration.</p> <p>TODO: Game summary</p>"},{"location":"python/pygame/bugs/#step-0-create-the-project-in-replit","title":"Step 0: Create the project in Replit","text":"<p>Navigate to Replit and login.</p> <p>Create a new project using the Pygame template and give it the title \"Bugs\" as illustrated by the screenshot below.</p> <p></p> <p>In the <code>main.py</code> file, replace the code provided with the code below and run the program to make sure it can download the packages and runs. You should be presented with a black screen with a red zero for the score at the top of the screen.</p> <pre><code>import time\nimport pgzrun\nimport types\n\nWIDTH = 640\nHEIGHT = 700\n\nscore = 0\nlives = 3\npaused = False\n\ndef draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\npgzrun.go()\n</code></pre>"},{"location":"python/pygame/classes_and_inheritance/","title":"Classes and inheritance","text":"<p>This short sub-section introduces the Python concepts of classes and inheritance. Once you have completed this sub-section, you can read more about classes and inheritance from the following online materials:</p> <ul> <li>Python Classes reference</li> <li>Python Inheritance reference</li> <li>Python Classes tutorial</li> </ul>"},{"location":"python/pygame/classes_and_inheritance/#common-behaviour","title":"Common behaviour","text":"<p>In Smash, eight classes were created to represent the different game objects:</p> <ul> <li><code>Paddle</code></li> <li><code>Ball</code></li> <li><code>Block</code></li> <li><code>ParticleScore</code></li> <li><code>ParticleExplosion</code></li> <li><code>BonusLives</code></li> <li><code>BonusPaddle</code></li> <li><code>BonusSpeed</code></li> </ul> <p>When writing the code for those classes, did you notice how similar the classes were?</p> <p>The following properties and methods are present in many of the classes:</p> <ul> <li><code>draw()</code></li> <li><code>update()</code></li> <li><code>bounding_box</code></li> <li><code>position</code></li> <li><code>alive</code></li> </ul> <p>This is because each of the classes represent game objects and the game itself expects each game object to have certain behaviour, such as being able to <code>draw()</code> itself. In Smash, we implemented the expected behaviour in each of the classes separately. Wouldn't it be great if there was a handy way to share that functionality so we only needed to implement it once? There is: inheritance. But before we get to that, we are going to start with a simple demonstration program that has objects from 2 types of class.</p>"},{"location":"python/pygame/classes_and_inheritance/#demonstration-program","title":"Demonstration program","text":"<p>Copy the following code into a PyGame Zero project in Replit which will randomly place <code>Square</code>s or <code>Circle</code>s at the top of the screen allowing them to fall down to the bottom for some seconds.</p> <pre><code>from random import randint\n\nfrom pgzero.rect import Rect\nfrom pgzero.screen import Screen\n\nWIDTH = 640\nHEIGHT = 800\nGRAVITY = 120\n\nscreen: Screen\n\ngame_objects = []\n\n\ndef draw():\n    screen.fill((0, 0, 0))\n\n    for game_object in game_objects:\n        game_object.draw(screen.draw)\n\n\ndef update(dt):\n    global game_objects\n\n    choice = randint(1, 30)\n    if choice == 1:\n        box = Square(100, 100, 10)\n        game_objects.append(box)\n    elif choice == 2:\n        circle = Circle(200, 100, 5)\n        game_objects.append(circle)\n\n    for game_object in game_objects:\n        game_object.update(dt)\n\n    game_objects = [game_object for game_object in game_objects if game_object.alive]\n\n\nclass Square:\n    def __init__(self, x, y, width):\n        self.x = x\n        self.y = y\n        self.lifetime = 5\n        self.colour = (90, 180, 90)\n        self.width = width\n\n    @property\n    def alive(self):\n        return self.lifetime &gt; 0\n\n    def update(self, dt):\n        self.lifetime -= dt\n        self.y += GRAVITY * dt\n\n    def draw(self, draw):\n        half_width = self.width / 2\n        rect = Rect(self.x - half_width, self.y - half_width, self.width, self.width)\n        draw.filled_rect(rect, self.colour)\n\n\nclass Circle:\n    def __init__(self, x, y, radius):\n        self.x = x\n        self.y = y\n        self.lifetime = 5\n        self.colour = (3, 50, 90)\n        self.radius = radius\n\n    @property\n    def alive(self):\n        return self.lifetime &gt; 0\n\n    def update(self, dt):\n        self.lifetime -= dt\n        self.y += GRAVITY * dt\n\n    def draw(self, draw):\n        draw.filled_circle((self.x, self.y), self.radius, self.colour)\n\nimport pgzrun\npgzrun.go()\n</code></pre> <p>When you run the code, you will be rewarded with two streams of shapes falling down the screen as in the image below. Notice how the code for the <code>Square</code> and <code>Circle</code> is almost exactly the same, with differences in only the <code>__init__()</code> and <code>draw()</code> methods. What if we also want to add in triangles and rectangles to our demo? Would we really need to duplicate all that code another two times?</p> <p></p>"},{"location":"python/pygame/classes_and_inheritance/#a-common-ancestor","title":"A common ancestor","text":"<p>From the previous code, lets make a new class called <code>Shape</code> that has all of the code that is common between <code>Square</code> and <code>Circle</code>. It will look like the code below. Note that there is no <code>update()</code> method and the <code>__init__()</code> method only sets <code>x</code>, <code>y</code> and <code>lifetime</code>:</p> <pre><code>class Shape:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.lifetime = 5\n\n    @property\n    def alive(self):\n        return self.lifetime &gt; 0\n\n    def update(self, dt):\n        self.lifetime -= dt\n        self.y += GRAVITY * dt\n</code></pre> <p>We can now adapt our original classes to <code>inherit</code> the functionality of <code>Shape</code>. This is done by copying in the code for the <code>Shape</code> class before the <code>Square</code> and <code>Circle</code> shapes, then changing the <code>class Square:</code> to <code>class Square(Shape):</code> as shown below:</p> <pre><code>class Square(Shape):\n    def __init__(self, x, y, width):\n        self.x = x\n        self.y = y\n        self.lifetime = 5\n        self.colour = (90, 180, 90)\n        self.width = width\n\n    @property\n    def alive(self):\n        return self.lifetime &gt; 0\n\n    def update(self, dt):\n        self.lifetime -= dt\n        self.y += GRAVITY * dt\n\n    def draw(self, draw):\n        half_width = self.width / 2\n        rect = Rect(self.x - half_width, self.y - half_width, self.width, self.width)\n        draw.filled_rect(rect, self.colour)\n</code></pre> <p>Do the same for the <code>Circle</code> class and run your program to make sure it works. If you get stuck, the full code up to this point is here.</p>"},{"location":"python/pygame/classes_and_inheritance/#using-the-common-ancestor","title":"Using the common ancestor","text":"<p>Both <code>Square</code> and <code>Circle</code> descend from <code>Shape</code> but still contain the duplicated code. The code that in the <code>Shape</code> class can be removed from  <code>Square</code> and <code>Circle</code>. The duplicated code that can be removed is the <code>alive</code> property, the <code>update</code> method and the <code>x</code>, <code>y</code> and <code>lifetime</code> variables in the <code>__init__()</code> method. The modified <code>Square</code> class is shown below:</p> <pre><code>class Square(Shape):\n    def __init__(self, x, y, width):\n        self.colour = (90, 180, 90)\n        self.width = width\n\n    def draw(self, draw):\n        half_width = self.width / 2\n        rect = Rect(self.x - half_width, self.y - half_width, self.width, self.width)\n        draw.filled_rect(rect, self.colour)\n</code></pre> <p>Do the same for the <code>Circle</code> class. If you get stuck, the full code up to this point is here.</p> <p>Run your program now. What happens? Do you get a scary looking error that ends with <code>AttributeError: 'Square' object has no attribute 'lifetime'</code>?</p>"},{"location":"python/pygame/classes_and_inheritance/#calling-the-parent","title":"Calling the parent","text":"<p>The error message that you saw in the previous step provides a hint as to what has gone wrong: the <code>lifetime</code> variable does not exist in your class. So why is this? Your <code>Square</code> and <code>Circle</code> classes inherit from the <code>Shape</code> class. The <code>x</code>, <code>y</code> and <code>lifetime</code> variables are added to your classes in <code>__init__()</code> method of the <code>Shape</code> class. However, because your classes provide <code>__init__()</code> methods of their own, the <code>Shape</code> <code>__init__()</code> method is not used. This is called overriding and you can read more about it in the links provided at the top of the page.</p> <p>So what do we do about it in our code? We call the <code>__init__()</code> method of the <code>Shape</code> class from our own classes. This is done by adding <code>super().__init__(x, y)</code> to the start of the <code>__init__()</code> method of the <code>Square</code> and <code>Circle</code> classes. This is shown below for the <code>Square</code> class.</p> <pre><code>    def __init__(self, x, y, width):\n        super().__init__(x, y)\n        self.colour = (90, 180, 90)\n        self.width = width\n</code></pre> <p>Make the same change for the <code>Circle</code> class. If you get stuck, the full code up to this point is here.</p>"},{"location":"python/pygame/classes_and_inheritance/#adding-a-triangle","title":"Adding a Triangle","text":"<p>Now we are going to extend our code to draw triangles too. Our triangle will have three points, each defined by a single <code>size</code> parameter:</p> <ol> <li>1 north of <code>(x, y)</code>.</li> <li>1 south east of  <code>(x, y)</code>.</li> <li>1 south west of  <code>(x, y)</code>.</li> </ol> <p>Because we can make another subclass of <code>Shape</code>, we can follow the same pattern as the <code>Square</code> and <code>Circle</code> classes. Add the following code immediately below the <code>Square</code> and <code>Circle</code> classes:</p> <pre><code>class Triangle(Shape):\n    def __init__(self, x, y, size):\n        super().__init__(x, y)\n        self.colour = (150, 150, 90)\n        self.size = size\n\n    def draw(self, draw):\n        top = (self.x, self.y - self.size)\n        east = (self.x - self.size, self.y + self.size)\n        west = (self.x + self.size, self.y + self.size)\n        draw.line(top, east, self.colour)\n        draw.line(top, west, self.colour)\n        draw.line(east, west, self.colour)\n</code></pre> <p>If you run your game, no <code>Triangle</code> shapes will be displayed. This is because we have not yet created any to display. The <code>update()</code> function is where we create these shapes. Add the following code to the <code>update ()</code> function after the code that creates the <code>Circle</code> shapes. Run your program, it should look similar to the screen shot below. If you have any difficulty, the full code can be found here.</p> <pre><code>    elif choice == 3:\n        triangle = Triangle(300, 100, 5)\n        game_objects.append(triangle)\n</code></pre> <p></p>"},{"location":"python/pygame/classes_and_inheritance/#experiment","title":"Experiment","text":"<p>Now try adding a Rectangle shape to your demonstration?</p> <p>What other shapes can you think of adding?</p>"},{"location":"python/pygame/invaders/","title":"Invaders","text":"<p>These instructions will take you through the steps of creating a game that uses the 1978 game Space Invaders as its inspiration.</p> <p>TODO: Game summary</p>"},{"location":"python/pygame/invaders/#step-0-create-the-project-in-replit","title":"Step 0: Create the project in Replit","text":"<p>Navigate to Replit and login.</p> <p>Create a new project using the Pygame template and give it the title \"Invaders\" as illustrated by the screenshot below.</p> <p></p> <p>In the <code>main.py</code> file, replace the code provided with the code below and run the program to make sure it can download the packages and runs. You should be presented with a black screen with a red zero for the score at the top of the screen.</p> <pre><code>import time\nimport pgzrun\nimport types\n\nWIDTH = 640\nHEIGHT = 700\n\nscore = 0\nlives = 3\npaused = False\n\ndef draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\npgzrun.go()\n</code></pre>"},{"location":"python/pygame/list_comprehensions/","title":"List comprehensions","text":"<p>This short sub-section provides additional information on list comprehensions as they are used commonly in Python code due to their conciseness. For a complete description of list comprehensions, see the official Python documentation here which describes list comprehensions as:</p> <p>List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.</p> <p>In Smash, list comprehension were introduced in the following places:</p> <ul> <li><code>check_for_collisions()</code> in Step 6: Destroying the blocks</li> <li><code>ParticleExplosion.update()</code> in Step 9: Add particle effects, Explosion particle effect</li> </ul> <p>We will now look at each of those list comprehensions, breaking them down into more traditional loops so you can see more clearly how they work.</p>"},{"location":"python/pygame/list_comprehensions/#check_for_collisions-in-step-6-destroying-the-blocks","title":"<code>check_for_collisions()</code> in Step 6: Destroying the blocks","text":"<p>The following excerpt shows the section of code with the list comprehension in <code>check_for_collisions()</code>.</p> <pre><code>blocks_to_destroy = [block for block in blocks if ball.collide(block.bounding_box)]\n</code></pre> <p>This type of list comprehension is very common. You will see these regularly in Python code. What this code is doing is looping over every <code>block</code> in the <code>blocks</code> list. Each block is checked for whether it collides with the <code>ball</code>. If it does, it is added to a new list. The new list is is then assigned to the <code>blocks_to_destroy</code> variable.</p> <p>The above single line list comprehension is equivalent to the following 4 lines of code:</p> <pre><code>blocks_to_destroy = []\n\nfor block in blocks:\n\n    if ball.collide(block.bounding_box)\n\n        blocks_to_destroy.append(block)\n</code></pre> <p>Can you see how each of the first 3 lines of code maps to the list comprehension?</p>"},{"location":"python/pygame/list_comprehensions/#a-new-example","title":"A new example","text":"<p>We will now work through a new example that you can run in Replit to demonstrate the functionality of a list comprehension and experiment with it. We will first start with the code using a plain ld loop and then turn it into a list comprehension. The example we will be using is to select all numbers that are negative from a list of 10 numbers.</p> <p>Type in the following code and run it.</p> <pre><code>\nnumbers = [1, -1, 30, -400, -5, 13, 17, -27, 0, 1000]\n\nnegative_numbers = []\n\nfor number in numbers:\n\n    if number &lt; 0:\n\n        negative_numbers.append(number)\n\nprint(negative_numbers)\n</code></pre> <p>You should see the following output:</p> <pre><code>[-1, -400, -5, -27]\n</code></pre> <p>Using the same pattern as before, the list comprehension can be build from the parts of the loop code. The entire section of code above can be condensed into:</p> <pre><code>numbers = [1, -1, 30, -400, -5, 13, 17, -27, 0, 1000]\n\nnegative_numbers = [number for number in numbers if number &lt; 0]\n\nprint(negative_numbers)\n</code></pre>"},{"location":"python/pygame/list_comprehensions/#experiments","title":"Experiments","text":"<p>Change the code so that it only selects positive numbers.</p> <p>Change the code so that it only selects numbers greater than 100.</p> <p>Change the code so that is only selects numbers whose magnitude is greater than 20. To get the magnitude you can use the built in function <code>abs()</code>. For information see the following resources:</p> <ul> <li>Python abs() function reference</li> <li>How to Find an Absolute Value in Python</li> </ul>"},{"location":"python/pygame/list_comprehensions/#particleexplosionupdate-in-step-9-add-particle-effects","title":"<code>ParticleExplosion.update()</code> in Step 9: Add particle effects","text":"<p>The following except shows the section of code that creates the <code>particles</code> list in the <code>__init__()</code> method as well as the list comprehension in the <code>update()</code> method of the <code>ParticleExplosion</code> class.</p> <pre><code>GRAVITY = 60\n\nclass ParticleExplosion:\n    def __init__(self, pos, lifetime, colour):\n        self.particles = [(pos[0], pos[1], randint(-90, 90), randint(-90, 90)) for _ in range(30)]\n\n    def update(self, dt):\n        self.particles = [(particle[0] + (particle[2] * dt),\n                           particle[1] + (particle[3] * dt), particle[2],\n                           particle[3] + (GRAVITY * dt))\n                          for particle in self.particles]\n</code></pre> <p>This looks more complicated than the first example but it really isn't. We can remove some of the code to make an more easily testable piece of code as follows (note, this code reduces the number of particles from 30 to 5):</p> <pre><code>from random import randint\n\nGRAVITY = 60\nx = 10\ny = 20\npos = (x, y)\nparticles = [(pos[0], pos[1], randint(-90, 90), randint(-90, 90)) for _ in range(5)]\nprint(particles)\n\ndt = 1\nparticles = [(particle[0] + (particle[2] * dt),\n              particle[1] + (particle[3] * dt), particle[2],\n              particle[3] + (GRAVITY * dt))\n             for particle in particles]\nprint(particles)\n</code></pre> <p>Run the above code in Replit and you will get output similar to this below:</p> <pre><code>[(10, 20, 32, -66), (10, 20, -69, -74), (10, 20, -85, 56), (10, 20, -90, -68), (10, 20, -78, -39)]\n[(42, -46, 32, -6), (-59, -54, -69, -14), (-75, 76, -85, 116), (-80, -48, -90, -8), (-68, -19, -78, 21)]\n</code></pre> <p>This is the list comprehension:</p> <pre><code>particles = [(particle[0] + (particle[2] * dt),\n              particle[1] + (particle[3] * dt), particle[2],\n              particle[3] + (GRAVITY * dt))\n             for particle in particles]\n</code></pre> <p>Now lets break this down to a standard loop as we did before:</p> <pre><code>new_particles = []\nfor particle in particles:\n    x, y, vx, vy = particle\n    new_x = x + vx * dt\n    new_y = y + vy * dt\n    new_vy = vy + GRAVITY * dt\n    new_particles.append((new_x, new_y, vx, new_vy))\n\nparticles = new_particles\nprint(particles)\n</code></pre> <p>Because the above code uses intermediate variables, each of the items in the <code>particle</code> tuple is given a name of <code>x</code>, <code>y</code>, <code>vx</code> or <code>vy</code> which represents the <code>x</code> and <code>y</code> co-ordinate of the particle, the horizontal speed of the particle (<code>vx</code>) and the vertical speed of the particle (<code>vy</code>).</p> <p>What this code demonstrates that may not have been obvious in the first example above is the limitation that you should not mutate the contents of a list when looping over them. This is why the modified particles are first added to the <code>new_particles</code> list and then at the end of the code the <code>new_particles</code> list is assigned to <code>particles</code>. List comprehensions do not have this limitation.</p> <p>For more information on tuples, see:</p> <ul> <li>Python Tuples reference</li> <li>Tuples and Sequences</li> </ul>"},{"location":"python/pygame/list_comprehensions/#experiments_1","title":"Experiments","text":"<p>Replace the following line of code:</p> <p><code>new_particles.append((new_x, new_y, vx, new_vy))</code></p> <p>With:</p> <p><code>particles.append((new_x, new_y, vx, new_vy))</code></p> <p>And remove the <code>particles = new_particles</code> line of code.</p> <p>Run your program. What happens?</p>"},{"location":"python/pygame/muncher/","title":"Muncher","text":"<p>These instructions will take you through the steps of creating a game that uses the 1980 game Pac-Man as its inspiration. In this version, the ghosts are not constrained by walls so can float through them.</p> <p>You will control Muncher, moving him around the screen to collect all the pellets whilst avoiding being caught by the ghosts.</p> <p>Eat a power pellet to super charge Muncher and allow him to eat the ghosts.</p> <p>When fruit appears, munch them for a big bonus.</p> <p>Get a new life for each 10,000 points scored.</p> <p></p>"},{"location":"python/pygame/muncher/#learning-points","title":"Learning points","text":"<p>These instructions will take you through the process of creating a game which uses the fundamental PyGame Zero classes with fundamental Python code concepts including:</p> <ul> <li>variables</li> <li>lists</li> <li>functions</li> <li>if/else conditions</li> <li>loops</li> </ul> <p>Some techniques are introduced that demonstrate introspection of Python objects as well as how to attach additional functionality to existing Actors.</p> <p>These instructions are suitable for you if you are comfortable with basic Python coding.</p>"},{"location":"python/pygame/muncher/#step-0-create-the-project-in-replit","title":"Step 0: Create the project in Replit","text":"<p>Navigate to Replit and login.</p> <p>Create a new project using the Pygame template and give it the title \"Muncher\" as illustrated by the screenshot below.</p> <p></p> <p>In the <code>main.py</code> file, replace the code provided with the code below and run the program to make sure it can download the packages and runs. You should be presented with a black screen with a red zero for the score at the top of the screen.</p> <pre><code>import time\nimport pgzrun\nimport types\n\nWIDTH = 640\nHEIGHT = 700\n\nscore = 0\nlives = 3\npaused = False\n\ndef draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\npgzrun.go()\n</code></pre>"},{"location":"python/pygame/muncher/#step-1-introducing-muncher","title":"Step 1: Introducing Muncher","text":"<p>Our protagonist is called Muncher and is a yellow round ball that likes to eat little yellow pellets. Muncher will be comtrolled by the player and can be moved around the screen using the cursor keys. Muncher will be 32 x 32 pixels in size and will be animated. Therefore you will need at least 2 images for Muncher. You can create your own images using a paint program that supports transparency (all the images provided here were created using PixilArt) or you can use my images that are provided below.</p> <p>The two images should be called <code>muncher.png</code> and <code>muncher2.png</code>. Create a <code>images</code> folder in your project and place your files in there as illustrated in the screenshot below.</p> <ul> <li><code>muncher.png</code> </li> <li><code>muncher2.png</code> </li> </ul> <p></p> <p>Then add the following code before the <code>draw()</code> function:</p> <pre><code>MUNCHER_START_X = WIDTH / 2\nMUNCHER_START_Y = (HEIGHT / 4) * 3\nmuncher = Actor('muncher', (MUNCHER_START_X, MUNCHER_START_Y))\nmuncher.images = ['muncher', 'muncher2']\nmuncher.vx = 150\nmuncher.vy = 150\n</code></pre> <p>Then change the <code>draw()</code> function to read as follows to ensure Muncher gets drawn each frame:</p> <pre><code>def draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\n    muncher.draw()\n</code></pre> <p>To add movement for Muncher, add an <code>update()</code> function after the <code>draw()</code> function. The <code>update()</code> function will move Muncher up, down, left or right at the correct speed (using Munchers horixontal and vertical velocity properties in pixels per second multiplied by the proportion of seconds that have passed since the last update):</p> <pre><code>def update(dt):\n    if keyboard.left:\n        muncher.x -= muncher.vx * dt\n    if keyboard.right:\n        muncher.x += muncher.vx * dt\n    if keyboard.up:\n        muncher.y -= muncher.vy * dt\n    if keyboard.down:\n        muncher.y += muncher.vy * dt\n</code></pre> <p>Try out your game. You should be able to move Muncher around the screen.</p>"},{"location":"python/pygame/muncher/#experiment-changing-the-speed-of-muncher","title":"Experiment: Changing the speed of Muncher","text":"<p>The speed of Muncher is controlled by the <code>vx</code> and <code>vy</code> properties that represent the horizontal and vertical speed that Muncher can move in pixels per second. These are currently set to <code>150</code> each in your code. Try experimenting with different values to see what effect this has. Example values to try are:</p> <ul> <li>300</li> <li>50</li> <li>0</li> <li>-150</li> </ul>"},{"location":"python/pygame/muncher/#step-2-keeping-actors-within-the-screen","title":"Step 2: Keeping Actors within the screen","text":"<p>What happens when Muncher gets close to the edges of the screen? Does he stop or keep going so he goes outside the bounds of the screen?</p> <p>During the game, we want Muncher to stay within the play area. We are therefore going to need to to set some boundaries that we want to keep all Actors (ghosts and Muncher) within. This boundary will be set to a border of 50 pixels. We will add a <code>keep_in_bounds()</code> method to the <code>Actor</code> class which we can call in each <code>update()</code> call. Add the following code above your <code>draw()</code> function:</p> <pre><code>BOUNDS_X1 = 50\nBOUNDS_Y1 = 50\nBOUNDS_X2 = WIDTH - BOUNDS_X1\nBOUNDS_Y2 = HEIGHT - BOUNDS_Y1\n\ndef keep_in_bounds(actor):\n    if actor.x &lt; BOUNDS_X1:\n        actor.x = BOUNDS_X1\n    elif actor.x &gt; BOUNDS_X2:\n        actor.x = BOUNDS_X2\n\n    if actor.y &lt; BOUNDS_Y1:\n        actor.y = BOUNDS_Y1\n    elif actor.y &gt; BOUNDS_Y2:\n        actor.y = BOUNDS_Y2\n\n\nActor.keep_in_bounds = keep_in_bounds\n</code></pre> <p>Then add <code>muncher.keep_in_bounds()</code> to the end of your <code>update()</code> function so it reads as follows:</p> <pre><code>def update(dt):\n    if keyboard.left:\n        muncher.x -= muncher.vx * dt\n    if keyboard.right:\n        muncher.x += muncher.vx * dt\n    if keyboard.up:\n        muncher.y -= muncher.vy * dt\n    if keyboard.down:\n        muncher.y += muncher.vy * dt\n\n    muncher.keep_in_bounds()\n</code></pre> <p>Try out your game. You should be able to move Muncher around the screen but cannot go outside the bounds.</p>"},{"location":"python/pygame/muncher/#experiment-changing-the-bounds","title":"Experiment: Changing the bounds","text":"<p>The variables <code>BOUNDS_X1</code> and <code>BOUNDS_Y1</code> set the width of the border around the screen. Try using diffent values and see how it changes the playing area. Example values to try are:</p> <ul> <li>0</li> <li>250</li> <li>-50</li> </ul>"},{"location":"python/pygame/muncher/#explanation-why-is-muncher-faster-when-moving-diagonally","title":"Explanation: Why is Muncher faster when moving diagonally?","text":"<p>Muncher has two properties that are used to determine his velocity: <code>vx</code> and <code>vy</code>. These represent the horizontal and vertical velocity that Muncher moves. If moving just left or right, the speed of Muncher is the value of the <code>vx</code> parameter, in this case 150 pixels per second. If moving just up or down, the speed of Muncher is the value of the <code>vx</code> parameter, again 150 pixels per second. However, if Muncher moves diagonally, he Moves 150 pixels left or right AND 150 pixels up or down. This is a right angled triangle and pythagoras theorem can be used to determine the distance actually moved which is about 212 pixels. A move consistent movement speed could be implemented by testing whether Muncher is moving diagonally or not but that would complicate the move calculation code. Besides, having a slightly faster diagonal move speed adds an additional strategy to the game and is a fun side effect.</p>"},{"location":"python/pygame/muncher/#step-3-animating-actors","title":"Step 3: Animating Actors","text":"<p>We want all of our Actors to be animated. At present, as Muncher runs around the screen he looks a little boring. In the code that creates the Muncher <code>Actor</code>, we set an <code>images</code> property that contained the two images that we are going to use to animate Muncher.</p> <p>Above your <code>draw()</code> function, add the following code which adds an <code>animate()</code> method to the <code>Actor</code> class. This method first checks for the presence of some properties on the <code>Actor</code> instance and if not present, provides some default values.</p> <pre><code>def animate(actor):\n    if not hasattr(actor, \"images\"):\n        return\n    if not hasattr(actor, \"fps\"):\n        actor.fps = 5\n    if not hasattr(actor, \"next_frame\"):\n        actor.next_frame = time.time_ns()\n    if not hasattr(actor, \"frame\"):\n        actor.frame = 0\n\n    now = time.time_ns()\n\n    if now &gt; actor.next_frame:\n        actor.frame = (actor.frame + 1) % len(actor.images)\n        actor.image = actor.images[actor.frame]\n        while actor.next_frame &lt; now:\n            actor.next_frame += (1_000_000_000 / actor.fps)\n\n\nActor.animate = animate\n</code></pre> <p>Modify your <code>draw()</code> function to call the <code>animate()</code> method of Muncher. Your new <code>draw()</code> function will look like this:</p> <pre><code>def draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\n    muncher.animate()\n    muncher.draw()\n</code></pre>"},{"location":"python/pygame/muncher/#extension-more-complex-animations","title":"Extension: More complex animations","text":"<p>If you want to make more elaborate or complex animations, you can add more images to the <code>images</code> property of an Actor. For example, if you have an animation that spans 4 frames, you can change the <code>images</code> property of Muncher to read as follows:</p> <pre><code>muncher.images = ['muncher', 'muncher2', 'muncher3', 'muncher4']\n</code></pre>"},{"location":"python/pygame/muncher/#experiment-animation-speed","title":"Experiment: Animation speed","text":"<p>You can also adjust the speed with which Muncher is animated by providing a value for the <code>fps</code> property on Muncher. By default, this will be set to 5 fps (Frames Per Second). Try experimenting with different values by adding the following code immediately after you set the <code>vx</code> and <code>vy</code> properties of Muncher:</p> <pre><code>muncher.fps = 15\n</code></pre> <p>Try experimenting with different values. Examples to try are:</p> <ul> <li>1</li> <li>2</li> <li>15</li> </ul>"},{"location":"python/pygame/muncher/#step-4-drawing-lives","title":"Step 4: Drawing lives","text":"<p>In this game, Muncher will start with 3 lives. We should add an indicator to the top of the screen to indicate how many lives Muncher has. Modify your <code>draw()</code> function so that it looks as follows:</p> <pre><code>def draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\n    for i in range(lives):\n        screen.blit('muncher', (5 + (37 * i), 5))\n\n    muncher.animate()\n    muncher.draw()\n</code></pre>"},{"location":"python/pygame/muncher/#step-5-introducing-the-ghosts","title":"Step 5: Introducing the ghosts","text":"<p>Muncher is antagonised by four ghosts, Blue, Orange, Red and Pink. Each of the ghosts will be animated so will require at least 2 images. Just like Muncher, all of the ghost images should be 32 x 32 pixels in size. You can create your own images using a paint program that supports transparency (all the images provided here were created using PixilArt) or you can use my images that are provided below.</p> <p>The images for each ghost should be placed in the <code>images</code> folder you already created and be called:</p> <ul> <li><code>ghost-blue.png</code> </li> <li><code>ghost-blue2.png</code> </li> <li><code>ghost-orange.png</code> </li> <li><code>ghost-orange2.png</code> </li> <li><code>ghost-red.png</code> </li> <li><code>ghost-red2.png</code> </li> <li><code>ghost-pink.png</code> </li> <li><code>ghost-pink2.png</code> </li> </ul> <p>Add the following code before the <code>draw()</code> function which will create the ghosts and give each one an individual speed and direction to start with but all will have the same starting position:</p> <pre><code>GHOST_START_X = WIDTH / 2\nGHOST_START_Y = (HEIGHT / 3)\nGHOST_START = (GHOST_START_X, GHOST_START_Y)\n\nblue = Actor('ghost-blue', GHOST_START)\nblue.images = ['ghost-blue', 'ghost-blue2']\nblue.vx = -160\nblue.vy = -160\n\norange = Actor('ghost-orange', GHOST_START)\norange.images = ['ghost-orange', 'ghost-orange2']\norange.vx = 260\norange.vy = 60\n\nred = Actor('ghost-red', GHOST_START)\nred.images = ['ghost-red', 'ghost-red2']\nred.vx = 40\nred.vy = 280\n\npink = Actor('ghost-pink', GHOST_START)\npink.images = ['ghost-pink', 'ghost-pink2']\npink.vx = 60\npink.vy = 60\n\nghosts = [blue, orange, red, pink]\n</code></pre> <p>Then change the <code>draw()</code> function to read as follows to ensure the ghosts all get animated and drawn each frame:</p> <pre><code>def draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\n    for i in range(lives):\n        screen.blit('muncher', (5 + (37 * i), 5))\n\n    muncher.animate()\n    muncher.draw()\n\n    for ghost in ghosts:\n        ghost.animate()\n        ghost.draw()\n</code></pre> <p>Run your program and see what happens? do the ghosts move? Why do you think this is?</p>"},{"location":"python/pygame/muncher/#extension-more-complex-ghost-animations","title":"Extension: More complex ghost animations","text":"<p>Just as you can for Muncher, you can make more elaborate or complex animations for the ghosts through using more animation frames by changing the <code>images</code> property of an Actor. For example, if you have an animation that spans 5 frames that you want to use for the blue ghost, you can change the <code>images</code> property of blue to read as follows:</p> <pre><code>blue.images = ['ghost-blue', 'ghost-blue2', 'ghost-blue3', 'ghost-blue4', 'ghost-blue5']\n</code></pre>"},{"location":"python/pygame/muncher/#step-6-moving-the-ghosts","title":"Step 6: Moving the ghosts","text":"<p>It looks like there is only a single ghost on the screen because they are all on top of each other and there is no code that does movement for the ghosts yet. The technique used for moving the ghosts is exactly the same as that for Muncher. We modify the ghosts position by its <code>vx</code> and <code>vy</code> properties based on the elaspsed time since the ghost was last moved.</p> <p>Add the following code above your <code>draw()</code> function:</p> <pre><code>def ghost_move(ghost, dt):\n    ghost.x += ghost.vx * dt\n    ghost.y += ghost.vy * dt\n\n\nfor ghost in ghosts:\n    ghost.move = types.MethodType(ghost_move, ghost)\n</code></pre> <p>Then modify the <code>update</code> function so that it calls the <code>move()</code> method for each of the ghosts in turn.</p> <pre><code>def update(dt):\n    if keyboard.left:\n        muncher.x -= muncher.vx * dt\n    if keyboard.right:\n        muncher.x += muncher.vx * dt\n    if keyboard.up:\n        muncher.y -= muncher.vy * dt\n    if keyboard.down:\n        muncher.y += muncher.vy * dt\n\n    muncher.keep_in_bounds()\n\n    for ghost in ghosts:\n        ghost.move(dt)\n</code></pre> <p>Run your program and see what happens. Do the ghosts stay in the play area like Muncher does? Why do you think this is? Can you fix it?</p>"},{"location":"python/pygame/muncher/#experiment-changing-the-ghosts-speed-and-direction","title":"Experiment: Changing the ghosts speed and direction","text":"<p>Just as it is for Muncher, the speed of the ghosts is controlled by the <code>vx</code> and <code>vy</code> properties that represent the horizontal and vertical speed each ghost can move in pixels per second. Each ghost has a different set of values for the <code>vx</code> and <code>vy</code> properties. Experiment with changing the values to see what effect it has.</p>"},{"location":"python/pygame/muncher/#step-7-keeping-the-ghosts-in-bounds","title":"Step 7: Keeping the ghosts in bounds","text":"<p>The reason the ghosts all fly off the screen is because we do not perform the check to keep them within the play area bounds like we do for Muncher. The code in the <code>update()</code> function is missing a call to <code>ghost.keep_in_bounds()</code>.</p> <p>Modify your <code>update()</code> function so that is is as follows:</p> <pre><code>def update(dt):\n    if keyboard.left:\n        muncher.x -= muncher.vx * dt\n    if keyboard.right:\n        muncher.x += muncher.vx * dt\n    if keyboard.up:\n        muncher.y -= muncher.vy * dt\n    if keyboard.down:\n        muncher.y += muncher.vy * dt\n\n    muncher.keep_in_bounds()\n\n    for ghost in ghosts:\n        ghost.move(dt)\n        ghost.keep_in_bounds()\n</code></pre> <p>What happens why you run your game now? Why do you think this is? How do you think you could go about fixing it?</p>"},{"location":"python/pygame/muncher/#experiment-adding-more-ghosts","title":"Experiment: Adding more ghosts","text":"<p>The game uses an Python list to store all of the ghosts in the game. This means that we do not need to do the movement and bounds checking for each ghost individually by their variables names <code>pink</code>, <code>blue</code>, <code>orange</code> and <code>red</code> but can instead iterate over all of the ghosts in a list and perform those operations. This is done in the <code>for ghost in ghosts:</code> statement in the <code>update()</code> function. The advantage of this method is that we can add more ghosts to the <code>ghosts</code> lists and they will automatically appear and move on the screen.</p> <p>Try it. Create another ghost called <code>blue2</code> (which will use the same images as <code>blue</code>) and add it to the <code>ghosts</code> lists. Run your game and check that it gets displayed and moves:</p> <pre><code>blue2 = Actor('ghost-blue', GHOST_START)\nblue2.images = ['ghost-blue', 'ghost-blue2']\nblue2.vx = -10\nblue2.vy = -60\n\nghosts = [blue, orange, red, pink, blue2]\n</code></pre> <p>Create some more ghosts called <code>yellow</code>, <code>mango</code>, <code>barry</code> and <code>dingo</code>. Create some super cool images and animations for them.</p>"},{"location":"python/pygame/muncher/#step-8-bouncing-the-ghosts","title":"Step 8: Bouncing the ghosts","text":"<p>When the game runs, the ghosts all wizz away and stay within the play area but they eventually all end up stuck in one of the corners. This is because the ghosts never change their direction. What we want to do is make the ghosts bounce at the edges of the play area.</p> <p>Change the <code>ghost_move()</code> function so that it is as follows:</p> <pre><code>def ghost_move(ghost, dt):\n    ghost.x += ghost.vx * dt\n    ghost.y += ghost.vy * dt\n\n    if ghost.x &gt;= BOUNDS_X2:\n        ghost.x = BOUNDS_X2\n        ghost.vx *= -1\n    elif ghost.x &lt;= BOUNDS_X1:\n        ghost.x = BOUNDS_X1\n        ghost.vx *= -1\n\n    if ghost.y &gt;= BOUNDS_Y2:\n        ghost.y = BOUNDS_Y2\n        ghost.vy *= -1\n    elif ghost.y &lt;= BOUNDS_Y1:\n        ghost.y = BOUNDS_Y1\n        ghost.vy *= -1\n</code></pre> <p>Run your game and you should now see your ghosts bouncing furiously around the screen.</p>"},{"location":"python/pygame/muncher/#step-9-muncher-and-ghost-collisions","title":"Step 9: Muncher and ghost collisions","text":"<p>At present, when a ghost collides with Muncher, nothing happens. What we want is for the collision to result in Muncher losing a life. Once a life is lost, we want a short pause, then all of the actors to return to their starting positions, another short pause and then the game to start again. The pauses will be controlled by chaining some function calls using the Pygame <code>clock</code> class. When all lives are lost, the game will <code>exit()</code>.</p> <p>Add the following two functions before your <code>draw()</code> function:</p> <pre><code>def unpause():\n    global paused\n    paused = False\n\n\ndef reset_actors():\n    for ghost in ghosts:\n        ghost.x = GHOST_START_X\n        ghost.y = GHOST_START_Y\n\n    muncher.x = MUNCHER_START_X\n    muncher.y = MUNCHER_START_Y\n\n    if lives &lt;= 0:\n        exit()\n\n    clock.schedule(unpause, 2)\n</code></pre> <p>The <code>update()</code> function needs two modifications done to it. The first modification is to do nothing when the game is <code>paused</code>. This is achieved with the following code at the start of the <code>update()</code> method:</p> <pre><code>def update(dt):\n    global lives, paused\n\n    if paused:\n        return\n</code></pre> <p>The second change is to check to see if any of the ghosts have collided with Muncher. This is achieved by adding the following code to the end of the <code>update()</code> function.</p> <pre><code>        for ghost in ghosts:\n            if ghost.colliderect(muncher):\n                lives -= 1\n                paused = True\n                clock.schedule(reset_actors, 2)\n</code></pre> <p>You entire <code>update()</code> function should now look as follows:</p> <pre><code>def update(dt):\n    global lives, paused\n\n    if paused:\n        return\n\n    if keyboard.left:\n        muncher.x -= muncher.vx * dt\n    if keyboard.right:\n        muncher.x += muncher.vx * dt\n    if keyboard.up:\n        muncher.y -= muncher.vy * dt\n    if keyboard.down:\n        muncher.y += muncher.vy * dt\n\n    muncher.keep_in_bounds()\n\n    for ghost in ghosts:\n        ghost.move(dt)\n        ghost.keep_in_bounds()\n\n    for ghost in ghosts:\n        if ghost.colliderect(muncher):\n            lives -= 1\n            paused = True\n            clock.schedule(reset_actors, 2)\n</code></pre>"},{"location":"python/pygame/muncher/#explanation-why-is-a-collision-detected-between-muncher-and-the-ghosts-when-they-dont-touch","title":"Explanation: Why is a collision detected between Muncher and the ghosts when they don't touch?","text":"<p>The collision detection algorithm that is used in this game is a relatively simple one. The code is checking whether the images of the <code>Actors</code> overlap each other. Those images are square 32 x 32 pixels but the image of Muncher does not use the entire square because Muncher is a circle. This means there are \"blank\" areas that surround Muncher in each corner. Our collision detection algorithm does not distinguish between the coloured in parts of the image and the blank areas, considering them all as Muncher. Therefore, it a ghost overlaps with one of these blank areas, it still registers as a collision. Later projects will look at implementing more advanced collision detection algorithms that offer higher fidelity.</p>"},{"location":"python/pygame/muncher/#step-10-walls-to-negotiate","title":"Step 10: Walls to negotiate","text":"<p>The play area needs some walls to make it more difficult for Muncher to avoid the ghosts. Two different images will be required for the walls. One is 128 x 32 pixels (representing a horizontal wall) and the other is 32 x 128 pixels (representing a vertical wall). You can create your own images using a paint program that supports transparency (all the images provided here were created using PixilArt) or you can use my images that are provided below.</p> <p>The two images should be called <code>wall.png</code> and <code>wall2.png</code> and placed in the <code>images</code> folder.</p> <ul> <li><code>wall.png</code> should be 128 x 32 pixels </li> <li><code>wall2.png</code> should be 32 x 128 pixels </li> </ul> <p>All wall elements will be created as <code>Actors</code>. Add the following code before your <code>draw()</code> function:</p> <pre><code>walls = [\n    Actor('wall', (WIDTH / 4, HEIGHT / 2)),\n    Actor('wall', ((WIDTH / 4) * 3, HEIGHT / 2)),\n    Actor('wall', (WIDTH / 2, HEIGHT / 5)),\n    Actor('wall', (WIDTH / 2, (HEIGHT / 5) * 4)),\n    Actor('wall2', (WIDTH / 5, HEIGHT / 3)),\n    Actor('wall2', ((WIDTH / 5) * 4, HEIGHT / 3)),\n    Actor('wall2', (WIDTH / 5, (HEIGHT / 3) * 2)),\n    Actor('wall2', ((WIDTH / 5) * 4, (HEIGHT / 3) * 2)),\n]\n</code></pre> <p>The <code>draw()</code> function needs to be updated to draw the walls. Add the additional code to the end of your <code>draw()</code> function which should now look as follows:</p> <pre><code>def draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\n    for i in range(lives):\n        screen.blit('muncher', (5 + (37 * i), 5))\n\n    muncher.animate()\n    muncher.draw()\n\n    for ghost in ghosts:\n        ghost.animate()\n        ghost.draw()\n\n    for wall in walls:\n        wall.draw()\n</code></pre> <p>Run your game. What happens when Muncher collides with a wall? Why do you think this is?</p>"},{"location":"python/pygame/muncher/#extension-adding-more-walls","title":"Extension: Adding more walls","text":"<p>Try extending your game to add more wall elements to the play area. Experiment with new images of different sizes to create interesting mazes and shapes. Just make sure to add all of your new wall elements to the <code>wall</code> list so that they will be displayed.</p>"},{"location":"python/pygame/muncher/#step-11-colliding-with-walls","title":"Step 11: Colliding with walls","text":"<p>We want the ghosts to be able to go through the walls, they are ghosts after all. However, we do not want Muncher to be able to go through the walls. We therefore need to check for collisions between Muncher and wall elements. The collision detection algorithm that we will be using is a relatively simple one that checks for overlaps of the edges of Muncher and the walls but is effective enough for this type of game.</p> <p>Add the following new collision detection function before your <code>draw()</code> function:</p> <pre><code>def check_for_wall_collisions(actor):\n    for wall in walls:\n        if wall.colliderect(actor):\n            # Try each of the edges of the wall\n            if actor.top &lt; wall.top and actor.bottom &gt; wall.top:\n                actor.bottom = wall.top\n\n            if actor.bottom &gt; wall.bottom and actor.top &lt; wall.bottom:\n                actor.top = wall.bottom\n\n            if actor.left &lt; wall.left and actor.right &gt; wall.left:\n                actor.right = wall.left\n\n            if actor.right &gt; wall.right and actor.left &lt; wall.right:\n                actor.left = wall.right\n</code></pre> <p>Then modify the <code>update()</code> function to check for collisions with muncher by adding the following statement to the end of <code>update()</code>: <code>check_for_wall_collisions(muncher)</code>. Your <code>update()</code> function should now look as follows:</p> <pre><code>def update(dt):\n    global lives, paused\n\n    if paused:\n        return\n\n    if keyboard.left:\n        muncher.x -= muncher.vx * dt\n    if keyboard.right:\n        muncher.x += muncher.vx * dt\n    if keyboard.up:\n        muncher.y -= muncher.vy * dt\n    if keyboard.down:\n        muncher.y += muncher.vy * dt\n\n    muncher.keep_in_bounds()\n\n    for ghost in ghosts:\n        ghost.move(dt)\n        ghost.keep_in_bounds()\n\n    for ghost in ghosts:\n        if ghost.colliderect(muncher):\n            lives -= 1\n            paused = True\n            clock.schedule(reset_actors, 2)\n\n    check_for_wall_collisions(muncher)\n</code></pre> <p>Run your game and check that Muncher cannot now pass through walls but the ghosts can.</p>"},{"location":"python/pygame/muncher/#step-12-pellets-to-eat","title":"Step 12: Pellets to eat","text":"<p>The pellets that Muncher likes to eat are small 8 x 8 pixel dots that are spread across the play area but not where there are walls. Either create your own image or use mine below, ensuring you copy it into the <code>images</code> folder.</p> <ul> <li><code>pellet.png</code> </li> </ul> <p>Add the following pellet creation function before your <code>draw()</code> function:</p> <pre><code>def create_pellets():\n    global pellets\n    pellets = []\n    for y in range(12):\n        for x in range(12):\n            pos = (50 + (50 * x), 100 + (50 * y))\n            collide = False\n            for wall in walls:\n                if wall.collidepoint(pos):\n                    collide = True\n\n            if not collide:\n                pellets.append(Actor('pellet', pos))\n\npellets = []\ncreate_pellets()\n</code></pre> <p>The <code>draw()</code> function needs to be updated to draw the pellets. Add the additional code to the end of your <code>draw()</code> function which should now look as follows:</p> <pre><code>def draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\n    for i in range(lives):\n        screen.blit('muncher', (5 + (37 * i), 5))\n\n    muncher.animate()\n    muncher.draw()\n\n    for ghost in ghosts:\n        ghost.animate()\n        ghost.draw()\n\n    for wall in walls:\n        wall.draw()\n\n    for pellet in pellets:\n        pellet.draw()        \n</code></pre> <p>Run your game and try to eat the pellets? What happens? Why do you think this is?</p>"},{"location":"python/pygame/muncher/#step-13-eating-the-pellets","title":"Step 13: Eating the pellets","text":"<p>Muncher cannot eat the pellets because we have not done the collision detection code for it yet. Add the new code to the end of the <code>update()</code> function to perform the collision detection and allow all of the pellets to be eaten.</p> <p>New code:</p> <pre><code>    global score, pellets\n    before = len(pellets)\n    pellets = [pellet for pellet in pellets if not pellet.colliderect(muncher)]\n    after = len(pellets)\n    score += (before - after) * 100\n</code></pre> <p>Your <code>update()</code> function should now be as follows:</p> <pre><code>def update(dt):\n    global lives, paused\n\n    if paused:\n        return\n\n    if keyboard.left:\n        muncher.x -= muncher.vx * dt\n    if keyboard.right:\n        muncher.x += muncher.vx * dt\n    if keyboard.up:\n        muncher.y -= muncher.vy * dt\n    if keyboard.down:\n        muncher.y += muncher.vy * dt\n\n    muncher.keep_in_bounds()\n\n    for ghost in ghosts:\n        ghost.move(dt)\n        ghost.keep_in_bounds()\n\n    for ghost in ghosts:\n        if ghost.colliderect(muncher):\n            lives -= 1\n            paused = True\n            clock.schedule(reset_actors, 2)\n\n    check_for_wall_collisions(muncher)\n\n    global score, pellets\n    before = len(pellets)\n    pellets = [pellet for pellet in pellets if not pellet.colliderect(muncher)]\n    after = len(pellets)\n    score += (before - after) * 100\n</code></pre> <p>What happens when you eat all of the pellets? How do you think you should fix this?</p>"},{"location":"python/pygame/muncher/#step-14-eating-all-of-the-pellets","title":"Step 14: Eating all of the pellets","text":"<p>When Muncher eats all of the pellets the game should start another level. Instead it just carries on. This is because we do not check that all pellets have been eaten. Add the new code to the end of the <code>update()</code> function to perform the check on how many pellets are left and start a new level if all have been eaten.</p> <p>New code:</p> <pre><code>    if len(pellets) &lt;= 0:\n        paused = True\n        create_pellets()\n        reset_actors()\n</code></pre> <p>Your <code>update()</code> function should now be as follows:</p> <pre><code>def update(dt):\n    global lives, paused\n\n    if paused:\n        return\n\n    if keyboard.left:\n        muncher.x -= muncher.vx * dt\n    if keyboard.right:\n        muncher.x += muncher.vx * dt\n    if keyboard.up:\n        muncher.y -= muncher.vy * dt\n    if keyboard.down:\n        muncher.y += muncher.vy * dt\n\n    muncher.keep_in_bounds()\n\n    for ghost in ghosts:\n        ghost.move(dt)\n        ghost.keep_in_bounds()\n\n    for ghost in ghosts:\n        if ghost.colliderect(muncher):\n            lives -= 1\n            paused = True\n            clock.schedule(reset_actors, 2)\n\n    check_for_wall_collisions(muncher)\n\n    global score, pellets\n    before = len(pellets)\n    pellets = [pellet for pellet in pellets if not pellet.colliderect(muncher)]\n    after = len(pellets)\n    score += (before - after) * 100\n\n    if len(pellets) &lt;= 0:\n        paused = True\n        create_pellets()\n        reset_actors()\n</code></pre>"},{"location":"python/pygame/muncher/#step-15-ghosts-with-personality","title":"Step 15: Ghosts with personality","text":"<p>Currently, the ghosts race around the screen in a fixed way which can make the game just a little bit predictable and easy. We are now going to program one of ghosts ghosts with some additional intelligence to make them chase after Muncher, rather than just race around the screen randomly.</p> <p>At the top of the file, add:</p> <pre><code>import types\n</code></pre> <p>Now we will add in the specific code for the more advanced movement for the blue ghost. This code should be added above your <code>draw()</code> function. This will make blue ghost move directly towards Muncher. This gives a simple chase type behaviour to the blue ghost, rather than just bouncing around the screen.</p> <pre><code>def chase(ghost, dt):\n    if ghost.vx &lt; 0:\n        ghost.vx *= -1\n\n    if ghost.vy &lt; 0:\n        ghost.vy *= -1\n\n    if ghost.x &lt; muncher.x:\n        ghost.x += ghost.vx * dt\n    else:\n        ghost.x -= ghost.vx * dt\n\n    if ghost.y &lt; muncher.y:\n        ghost.y += ghost.vy * dt\n    else:\n        ghost.y -= ghost.vy * dt\n\nblue.move = types.MethodType(chase, blue)\n</code></pre> <p>Run your game to make sure the ghost exhibits the new behaviour. Does the blue ghost now catch you really fast and is impossible to evade? Why do you think this is? Try changing the values that <code>blue.vx</code> and <code>blue.vy</code> are initialised to? What are good values?</p>"},{"location":"python/pygame/muncher/#extension-create-your-own-ai","title":"Extension: Create your own AI","text":"<p>Try to give some of your ghosts unique movement behaviours; some ghosts can keep using the default <code>ghost_move()</code> function. You can add the <code>chase()</code> move behaviour to other slower moving ghosts too.</p> <p>Create your own special move function for that can be attached to some of your ghosts. If you are stuck for ideas as to what to write as your algorithm, try this:</p> <ul> <li>Pick random <code>vx</code> and <code>vy</code> values for -40 to 40.</li> <li>Pick move in that direction for a random amount of time, ensuring to bounce off walls.</li> <li>Repeat</li> </ul>"},{"location":"python/pygame/muncher/#step-15-bonus-fruit","title":"Step 15: Bonus fruit","text":"<p>A diet of just chomping on pellets can get a little boring so Muncher like to also eat fruit when it is available. In our game, we want to occasionally make fruit available on the screen so that Muncher can get a big bonus for eating it. Only one fruit will be available at a time.</p> <p>We are going to start with three different types of fruit, each with a 32 x 32 pixel image. The three images should be placed in the <code>images</code> folder you already created and be called:</p> <ul> <li><code>apple.png</code> </li> <li><code>lemon.png</code> </li> <li><code>strawberry.png</code> </li> </ul> <p>Then add the following code before the <code>draw()</code> function which creates a list that contains an  <code>Actor</code> for each of the possible fruits we will display:</p> <pre><code>fruits = [\n    Actor('apple', (WIDTH / 2, HEIGHT / 2)),\n    Actor('lemon', (WIDTH / 2, HEIGHT / 2)),\n    Actor('strawberry', (WIDTH / 2, HEIGHT / 2)),\n]\n\nfruit = None\n</code></pre> <p>The <code>fruit</code> variable which is currently set to the special value <code>None</code> is used to indicate which fruit we are currently displaying. When <code>fruit</code> is <code>None</code> it means that no fruit is to be displayed. When <code>fruit</code> is an <code>Actor</code> then it is to be displayed. Change the <code>draw()</code> function to read as follows to ensure <code>fruit</code> gets drawn each frame when it is a value other than <code>None</code>:</p> <pre><code>def draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\n    for i in range(lives):\n        screen.blit('muncher', (5 + (37 * i), 5))\n\n    muncher.animate()\n    muncher.draw()\n\n    for ghost in ghosts:\n        ghost.animate()\n        ghost.draw()\n\n    for wall in walls:\n        wall.draw()\n\n    for pellet in pellets:\n        pellet.draw()\n\n    if fruit is not None:\n        fruit.draw()\n</code></pre> <p>Now run your game to check it out. Does the fruit get displayed? Why do you think this is?</p>"},{"location":"python/pygame/muncher/#extension-more-fruits-please","title":"Extension: More fruits please","text":"<p>Having 3 different fruits adds some variety but Muncher likes a whole lot of different types of fruit. Use your artistic talent to create more fruits. Don't forget to add them to the <code>fruits</code> list. Some examples of fruits to draw are:</p> <ul> <li>Banana</li> <li>Pineapple</li> <li>Cherries</li> <li>Kiwi</li> <li>Peach</li> <li>Grapes</li> </ul>"},{"location":"python/pygame/muncher/#step-17-showing-and-hiding-the-fruit","title":"Step 17: Showing and hiding the fruit","text":"<p>Presently, when the game is running, the fruits do not appear. This is because there is no code that currently changes the <code>fruit</code> variable from the value <code>None</code>. What we want is for a fruit to appear every five second and be displayed for 3 seconds. This should make it challenging for Muncher to get the fruit whilst also avoiding the ghosts. To achieve this we are going to use the <code>clock.schedule()</code> method that we used earlier. The method <code>clock.schedule()</code> is used to schedule a function to be called a number of seconds in the future. We will schedule a call pick a random fruit from the list to show and then schedule another different call to hide that fruit.</p> <p>Add the following code before the <code>draw()</code> function:</p> <pre><code>def show_fruit():\n    import random\n    global fruit\n    fruit = fruits[random.randint(0, len(fruits) - 1)]\n    clock.schedule(hide_fruit, 3)\n\n\ndef hide_fruit():\n    global fruit\n    fruit = None\n    clock.schedule(show_fruit, 5)\n\n\nclock.schedule(show_fruit, 5)\n</code></pre> <p>Run your program. Now your fruits will show and hide. What happens when Muncher touches the fruit? Why do you think that is?</p>"},{"location":"python/pygame/muncher/#experiment-changing-how-often-the-fruits-are-visible","title":"Experiment: Changing how often the fruits are visible","text":"<p>Try adjusting the specified number of seconds that the three calls to <code>clock.schedule()</code> to see how this affects the game. The three values represent:</p> <ul> <li>The time to wait for the first fruit being shown.</li> <li>The time that each fruit is displayed for.</li> <li>The time between each fruit being displayed.</li> </ul> <p>Which value is which? Select some values that you feel are best for your game.</p>"},{"location":"python/pygame/muncher/#step-18-eating-the-fruits","title":"Step 18: Eating the fruits","text":"<p>At present, when Muncher overlaps with the fruit, nothing happens. This is because we have not added the collision detection code like has been done for the pellets, ghosts and walls.</p> <p>Modify the <code>update</code> function so that it checks for the collision between Muncher and the fruit and awards points based on the index of the fruit in the list. The first item will be worth 1,000 points, the second item 2,000, the third item 3,000 points and so on.</p> <pre><code>    global fruit\n    if fruit is not None:\n        if fruit.colliderect(muncher):\n            index = fruits.index(fruit) + 1\n            score += (1000 * index)\n            fruit = None\n</code></pre> <p>Run your game and try it out.</p>"},{"location":"python/pygame/muncher/#experiment-fruits-in-different-places","title":"Experiment: Fruits in different places","text":"<p>All of the fruits currently appear in the same location no the screen. Why do you think this is? Try changing your code so that different fruits appear in different locations.</p>"},{"location":"python/pygame/muncher/#step-19-getting-additional-lives","title":"Step 19: Getting additional lives","text":"<p>An additional life should be awarded for each 10,000 points the player scores.</p> <p>Add the following code above your <code>draw()</code> function:</p> <pre><code>next_life = 10000\n</code></pre> <p>Modify the <code>update</code> function by adding the code below that checks to see when the next life should be awarded.</p> <pre><code>    global next_life\n    if score &gt;= next_life:\n        lives += 1\n        next_life += 10000\n</code></pre>"},{"location":"python/pygame/muncher/#experiment-changing-the-way-extra-lives-are-awarded","title":"Experiment: Changing the way extra lives are awarded","text":"<p>The code currently awards a new life every 10,000 points. Try changing it so that a life is awarded after the first 1,000 points and then every 2,000 points thereafter.</p> <p>What happens when you get lots and lots of lives?</p> <p>Try modifying the code so that you award lives in the following pattern:</p> <ul> <li>1st new life awarded after 10,000 points (10,000)</li> <li>2nd new life awarded after 30,000 points (10,000 + 20,000)</li> <li>3rd new life awarded after 60,000 points (10,000 + 20,000 + 30,000)</li> <li>4th new life awarded after 100,000 points (10,000 + 20,000 + 30,000 + 40,000)</li> <li>... and so on ...</li> </ul>"},{"location":"python/pygame/muncher/#step-20-power-pellets","title":"Step 20: Power pellets","text":"<p>Each time Muncher eats a power pellet, it supercharges Muncher and allows him to eat the ghosts for a few seconds. The power pellet is a larger 16 x 16 pixel pellet. You can create your own using whatever colour you like, or use mine.</p> <p>The image for the power pellet should be placed in the <code>images</code> folder you already created and be called:</p> <ul> <li><code>power-pellet.png</code> </li> </ul> <p>We will use the same pattern for creating the power pellets, drawing them and performing collision detection as has been used for the smaller pellets. You should be familiar with these patterns by now.</p> <p>Add the following code before the <code>create_pellets()</code> function which will create the list to hold the power pellets and add a property to Muncher to indicate how long he has left (in seconds) in power mode:</p> <pre><code>power_pellets = []\nmuncher.power = 0\n</code></pre> <p>Add the following code to the <code>create_pellets()</code> function which will create the power pellets for each new level:</p> <pre><code>    global power_pellets\n    power_pellets = [\n        Actor('power-pellet', (WIDTH / 5, HEIGHT / 6)),\n        Actor('power-pellet', ((WIDTH / 5) * 4, HEIGHT / 6)),\n    ]\n</code></pre> <p>Add the following code to the <code>draw()</code> function to display the power pellets each frame:</p> <pre><code>    for pellet in power_pellets:\n        pellet.draw()\n</code></pre> <p>Add the following code to the <code>update()</code> function. This code first decreases how much time Muncher has left in power mode and then detects for collision between Muncher and the power pellets, granting Muncher a 500 point bonus and more time in power mode if one or more power pellets were eaten:</p> <pre><code>    muncher.power -= dt\n    if muncher.power &lt; 0:\n        muncher.power = 0\n\n    global power_pellets\n    before = len(power_pellets)\n    power_pellets = [pellet for pellet in power_pellets if not pellet.colliderect(muncher)]\n    after = len(power_pellets)\n    score += (before - after) * 500\n    if after &lt; before:\n        muncher.power = 5\n</code></pre>"},{"location":"python/pygame/muncher/#experiment-changing-the-number-of-power-pellets","title":"Experiment: Changing the number of power pellets","text":"<p>Currently the game has two power pellets. Why not add some more power pellets to the game. You could go for four with one in each corner or perhaps place then extra ones in random positions. Experiment with different placings to get something you like.</p>"},{"location":"python/pygame/muncher/#step-21-power-mode-and-frightened-ghosts","title":"Step 21: Power mode and frightened ghosts","text":"<p>When you run your game, there is no indication that Muncher is in power mode. In fact even in power mode, Muncher will still lose a life if he touches the ghosts. We need to do the following things:</p> <ol> <li>Make the ghosts change their look so it is clear that power mode is activated</li> <li>Stop Muncher losing a life when colliding with a ghost in power mode.</li> <li>Award Muncher 500 bonus points when colliding with a ghost in power mode and move the ghost back to its starting position.</li> </ol> <p>Either draw your own 32 x 32 pixel scared ghost images using your favourite paint program or use my images below. The two scared ghost images should be placed in the <code>images</code> folder you already created and be called:</p> <ul> <li><code>ghost-scared.png</code> </li> <li><code>ghost-scared2.png</code> </li> </ul> <p>Add the following code before the <code>draw()</code> function which will create a list for the scared ghost images:</p> <pre><code>scared_images = ['ghost-scared', 'ghost-scared2']\n</code></pre> <p>Add the following code to the end of your <code>update()</code> function. This will swap the images used for each ghost <code>Actor</code> based on whether Muncher is in power mode or note:</p> <pre><code>    global scared_images\n    if muncher.power &gt; 0:\n        for ghost in ghosts:\n            if ghost.images != scared_images:\n                ghost.original_images = ghost.images\n                ghost.images = scared_images\n                ghost.frame = 0\n    else:\n        for ghost in ghosts:\n            if ghost.images == scared_images:\n                ghost.images = ghost.original_images\n                ghost.frame = 0\n</code></pre> <p>If you run your program now you will find the ghosts change their look when you eat a power pellet. The only item remaining is to modify the collision detection code.</p> <p>In your <code>update()</code> function, locate the code that checks the collision between Muncher and the ghosts. It will look like this:</p> <pre><code>    for ghost in ghosts:\n        if ghost.colliderect(muncher):\n            lives -= 1\n            paused = True\n            clock.schedule(reset_actors, 2)\n</code></pre> <p>Change it to this which will stop this collision detection happening if Muncher is in power mode:</p> <pre><code>    if muncher.power &lt;= 0:\n        for ghost in ghosts:\n            if ghost.colliderect(muncher):\n                lives -= 1\n                paused = True\n                clock.schedule(reset_actors, 2)\n</code></pre> <p>Now to add the code that allows Muncher to each the ghosts. Add this code to the end of your <code>update()</code> function:</p> <pre><code>    if muncher.power &gt; 0:\n        for ghost in ghosts:\n            if ghost.colliderect(muncher):\n                score += 500\n                ghost.pos = GHOST_START\n</code></pre>"},{"location":"python/pygame/muncher/#extension-frightened-ghosts-should-run-away","title":"Extension: Frightened ghosts should run away","text":"<p>Presently, when Muncher has eaten a power pellet, the ghosts do not change their behaviour. The ghosts moving randomly continue to do so and the ghosts chasing also continue to do so. Change your chase code so that you rather than chase towards Muncher a chasing ghost runs away when Muncher is in power mode.</p>"},{"location":"python/pygame/muncher/#step-22-adding-sounds","title":"Step 22: Adding sounds","text":"<p>You game is fun, but it is lacking something. Sound! You can create your own sound effects or use some free online resources. All of the sound effects listed here came from MixKit. Other sites are available such as pixabay.</p> <p>Create a <code>sounds</code> folder in your project to place your sound files. You will need 6 sounds:</p> <ul> <li>eat_ghost.wav</li> <li>eat_fruit.wav</li> <li>eat_pellet.wav</li> <li>lose_life.wav</li> <li>new_level.wav</li> <li>new_life.wav</li> </ul> <p>Playing a sound is super easy using the <code>sounds</code> object. To play the <code>lose_life.wav</code> sound, just use this code.</p> <pre><code>sounds.lose_life.play()\n</code></pre> <p>All of the sounds need adding to the <code>update()</code> function which should now look like this:</p> <pre><code>def update(dt):\n    global lives, paused\n\n    if paused:\n        return\n\n    if keyboard.left:\n        muncher.x -= muncher.vx * dt\n    if keyboard.right:\n        muncher.x += muncher.vx * dt\n    if keyboard.up:\n        muncher.y -= muncher.vy * dt\n    if keyboard.down:\n        muncher.y += muncher.vy * dt\n\n    muncher.keep_in_bounds()\n\n    for ghost in ghosts:\n        ghost.move(dt)\n        ghost.keep_in_bounds()\n\n    if muncher.power &lt;= 0:\n        for ghost in ghosts:\n            if ghost.colliderect(muncher):\n                lives -= 1\n                sounds.lose_life.play()\n                paused = True\n                clock.schedule(reset_actors, 2)\n\n    check_for_wall_collisions(muncher)\n\n    global score, pellets\n    before = len(pellets)\n    pellets = [pellet for pellet in pellets if not pellet.colliderect(muncher)]\n    after = len(pellets)\n    score += (before - after) * 100\n    if after &lt; before:\n        sounds.eat_pellet.play()\n\n    if len(pellets) &lt;= 0:\n        paused = True\n        sounds.new_level.play()\n        create_pellets()\n        reset_actors()\n\n    global fruit\n    if fruit is not None:\n        if fruit.colliderect(muncher):\n            sounds.eat_fruit.play()\n            index = fruits.index(fruit) + 1\n            score += (1000 * index)\n            fruit = None\n\n    global next_life\n    if score &gt;= next_life:\n        sounds.new_life.play()\n        lives += 1\n        next_life += 10000\n\n    muncher.power -= dt\n    if muncher.power &lt; 0:\n        muncher.power = 0\n\n    global power_pellets\n    before = len(power_pellets)\n    power_pellets = [pellet for pellet in power_pellets if not pellet.colliderect(muncher)]\n    after = len(power_pellets)\n    score += (before - after) * 500\n    if after &lt; before:\n        muncher.power = 5\n\n    global scared_images\n    if muncher.power &gt; 0:\n        for ghost in ghosts:\n            if ghost.images != scared_images:\n                ghost.original_images = ghost.images\n                ghost.images = scared_images\n                ghost.frame = 0\n    else:\n        for ghost in ghosts:\n            if ghost.images == scared_images:\n                ghost.images = ghost.original_images\n                ghost.frame = 0\n\n    if muncher.power &gt; 0:\n        for ghost in ghosts:\n            if ghost.colliderect(muncher):\n                sounds.eat_ghost.play()\n                score += 500\n                ghost.pos = GHOST_START\n</code></pre>"},{"location":"python/pygame/muncher/#extension-add-a-special-sound-when-a-power-pellet-is-eaten","title":"Extension: Add a special sound when a power pellet is eaten","text":"<p>There is currently no special sound played when a power pellet is eaten. Create or choose a sound, add it to your <code>sounds</code> directory, then add the code to play the sound when a power pellet is eaten.</p>"},{"location":"python/pygame/muncher/#extension-frightened-ghosts-sound","title":"Extension: Frightened ghosts sound","text":"<p>Extend your game to play a background melody when the ghosts are frightened.</p>"},{"location":"python/pygame/muncher/#appendix-a-finished-code","title":"Appendix A: Finished code","text":"<p>Here is a version of the finished code with some of the extensions completed: main.py</p> <p>You can see the completed game on Replit.</p>"},{"location":"python/pygame/pairs/","title":"Pairs","text":"<p>TODO: Game summary</p>"},{"location":"python/pygame/pairs/#create-the-project-in-replit","title":"Create the project in Replit","text":"<p>Navigate to Replit and login.</p> <p>Create a new project using the Pygame template and give it the title \"Pairs\" as illustrated by the screenshot below.</p> <p></p> <p>In the <code>main.py</code> file, replace the code provided with the code below and run the program to make sure it can download the packages and runs. You should be presented with a black screen with a red zero for the score at the top of the screen.</p> <pre><code>import time\nimport pgzrun\nimport types\n\nWIDTH = 640\nHEIGHT = 700\n\nscore = 0\npaused = False\n\ndef draw():\n    screen.clear()\n    screen.draw.text(f\"{score}\", (WIDTH / 2, 15), color=\"red\", fontsize=24)\n\npgzrun.go()\n</code></pre>"},{"location":"python/pygame/smash/","title":"Smash","text":"<p>These instructions will take you through the steps of creating a game that uses the 1976 game Breakout as its inspiration.</p> <p>You will control a paddle along the bottom of the screen to bounce balls at the grid of blocks across the top of the screen. Each time you clear all of the blocks, you will be given another life and advance a level to do it all again.</p> <p>The ball passes through some blocks and bounces on others. When destroyed, Some blocks drop a bonus that will be either more lives, a bigger paddle or slow the ball down.</p> <p>How many levels can you complete?</p> <p></p>"},{"location":"python/pygame/smash/#learning-points","title":"Learning points","text":"<p>These instructions will take you through the process of creating a game which does not use Actors for sprites. Instead, the game is implemented using drawing primitives such as rectangles, circles and individual pixels. Python Classes are used to implement the game objects with these primitives, showing the flexibility that is on offer.</p> <p>These instructions are suitable for you if you are comfortable with basic Python coding.</p>"},{"location":"python/pygame/smash/#step-0-create-the-project-in-replit","title":"Step 0: Create the project in Replit","text":"<p>Navigate to Replit and login.</p> <p>Create a new project using the Pygame template and give it the title \"Smash\" as illustrated by the screenshot below.</p> <p></p> <p>In the <code>main.py</code> file, replace the code provided with the code below and run the program to make sure it can download the packages and runs. You should be presented with a greenish black screen. You can change the colour of the background by modifying the value of the <code>BACKGROUND_COLOUR</code> variable. Colours are specified with 3 values that represent the red, green and blue components of the colour. Each component value can be between 0 and 255.</p> <p>The screen area of the game can be adjusted by changing the values of the <code>WIDTH</code> and <code>HEIGHT</code> variables. After clearing the screen, the <code>draw()</code> function loops over the list <code>draw_funcs</code>. In later steps we will be adding functions to this list to draw the elements on the screen. The advantage of this technique is that the <code>draw()</code> function will not need to modified in those later steps. We do a similar technique for the <code>update()</code> function.</p> <p>Experiment to find the colours and screen size that you like the most.</p> <pre><code>import os\nimport random\nfrom copy import copy\nfrom random import randint\n\nimport pgzrun\nfrom pgzero.clock import Clock\nfrom pgzero.keyboard import Keyboard\nfrom pgzero.rect import Rect\nfrom pgzero.screen import Screen\n\nWIDTH = 600\nHEIGHT = 640\n\nscreen: Screen\nkeyboard: Keyboard\nclock: Clock\n\nBACKGROUND_COLOUR = (5, 20, 0)\n\ndraw_funcs = []\n\ndef draw():\n    screen.fill(BACKGROUND_COLOUR)\n    for draw_func in draw_funcs:\n        draw_func(screen.draw)\n\nupdate_funcs = []\n\ndef update(dt):\n    for update_func in update_funcs:\n        update_func(dt)\n\npgzrun.go()\n</code></pre>"},{"location":"python/pygame/smash/#step-1-setup-score-level-border-and-lives","title":"Step 1: Setup score, level, border and lives","text":"<p>The completed code for this step is available here.</p> <p>Now we are going to draw the score, level, border and lives on the screen. We will create functions to draw each of the separate elements. Each section of code can be added and tested individually. Place the following code before the call to <code>pgzrun.go()</code>. Run your game after you have added each section and you should see each section as it gets added.</p>"},{"location":"python/pygame/smash/#add-the-score","title":"Add the score","text":"<pre><code>HEADER_HEIGHT = 40\nFOOTER_HEIGHT = 20\nMARGIN_WIDTH = 20\n\nSCORE_COLOUR = (0, 255, 0)\n\nscore = 0\n\ndef draw_score(draw):\n    draw.text(f\"{score}\",\n              center=(WIDTH / 2, HEADER_HEIGHT / 2),\n              color=SCORE_COLOUR,\n              fontsize=36)\n\ndraw_funcs.append(draw_score)\n</code></pre>"},{"location":"python/pygame/smash/#add-the-level","title":"Add the level","text":"<pre><code>LEVEL_COLOUR = (0, 255, 0)\n\nlevel = 1\n\ndef draw_level(draw):\n    draw.text(f\"Level: {level}\",\n              right=(WIDTH - MARGIN_WIDTH),\n              centery=HEADER_HEIGHT / 2,\n              color=LEVEL_COLOUR,\n              fontsize=36)\n\ndraw_funcs.append(draw_level)\n</code></pre>"},{"location":"python/pygame/smash/#add-the-border","title":"Add the border","text":"<pre><code>BORDER_COLOUR = (200, 0, 0)\nBORDER_WIDTH = 3\n\ndef draw_border(draw):\n    left = MARGIN_WIDTH\n    top = HEADER_HEIGHT\n    width = WIDTH - (2 * MARGIN_WIDTH)\n    height = HEIGHT - HEADER_HEIGHT - FOOTER_HEIGHT\n    draw.filled_rect(Rect(left, top, width, height), BORDER_COLOUR)\n\n    left += BORDER_WIDTH\n    top += BORDER_WIDTH\n    width -= (2 * BORDER_WIDTH)\n    draw.filled_rect(Rect(left, top, width, height), BACKGROUND_COLOUR)\n\ndraw_funcs.append(draw_border)\n</code></pre>"},{"location":"python/pygame/smash/#add-the-lives","title":"Add the lives","text":"<pre><code>LIVES_COLOUR = (200, 200, 0)\nLIVES_RADIUS = 8\nLIVES_SPACING = 5\n\nSTARTING_LIVES = 3\n\nlives = STARTING_LIVES\n\ndef draw_lives(draw):\n    for i in range(lives):\n        x = MARGIN_WIDTH + LIVES_RADIUS + (i * (\n            (2 * LIVES_RADIUS) + LIVES_SPACING))\n        y = HEADER_HEIGHT / 2\n        draw.filled_circle((x, y), LIVES_RADIUS, LIVES_COLOUR)\n\ndraw_funcs.append(draw_lives)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p></p>"},{"location":"python/pygame/smash/#experiment-changing-the-look-of-the-game","title":"Experiment: Changing the look of the game","text":"<p>The look of the game is controlled by the 10 variables that are in UPPERCASE at the start of the code you have just added. The names of the variables should be reasonably self explanatory. Experiment with different values for some of the variables and see how it changes the screen. Inspect the code to work out how the code achieves the effects.</p> <p>Some good values to experiment with:</p> <ul> <li><code>HEADER_HEIGHT</code>: 20, 40, 100, 200</li> <li><code>FOOTER_HEIGHT</code>: 10, 20, 40, 100</li> <li><code>MARGIN_WIDTH</code>: 10, 20, 40, 100</li> <li><code>BORDER_WIDTH</code>: 1, 3, 6, 20, 40</li> <li><code>LIVES_RADIUS</code>: 1, 3, 8, 12, 20, 50</li> <li><code>LIVES_SPACING</code>: -3, 0, 5, 10, 20</li> </ul> <p>Experiment with changing the colours to find some you like. As with the background, colours are specified with 3 values that represent the red, green and blue components of the colour. Each component value can be between 0 and 255.</p>"},{"location":"python/pygame/smash/#step-2-paddle-and-movement","title":"Step 2: Paddle and movement","text":"<p>The completed code for this step is available here.</p> <p>In this step, the paddle which can be moved across the bottom of the screen using the left and right arrow keys will be added. A Class called <code>Paddle</code> will be created to control how the paddle is draw and controlled. The following methods of the <code>Paddle</code> Class are worthy of a little more explanation.</p> <ul> <li><code>bounding_box()</code> - This returns a <code>Rect</code> instance that represents the space occupied by the   paddle. This is used later for collision detection.</li> <li><code>draw()</code> - This draws the paddle on the supplied <code>SurfacePainter</code> object.</li> <li><code>update()</code> - This is called to update the position of the paddle. As well as moving the   paddle in response to keypresses, it keeps the paddle in bounds.</li> </ul> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code>PADDLE_COLOUR = (200, 0, 0)\nPADDLE_WIDTH = 80\nPADDLE_HEIGHT = 6\nPADDLE_SPEED = 400\n\nclass Paddle:\n    def __init__(self, pos):\n        self.position = pos\n        self.width = PADDLE_WIDTH\n        self.height = PADDLE_HEIGHT\n        self.colour = PADDLE_COLOUR\n\n        # This is the speed the paddle can go left and right in pixels per second\n        self.vx = PADDLE_SPEED\n\n        # These are the bounds that the paddles box must stay within\n        self.min_x = MARGIN_WIDTH + (PADDLE_WIDTH / 2)\n        self.max_x = WIDTH - MARGIN_WIDTH - (PADDLE_WIDTH / 2)\n\n    @property\n    def bounding_box(self):\n        half_width = int(self.width / 2)\n        return Rect((self.x - half_width, self.y), (self.width, self.height))\n\n    @property\n    def position(self):\n        return self.x, self.y\n\n    @position.setter\n    def position(self, pos):\n        self.x = pos[0]\n        self.y = pos[1]\n\n    def draw(self, draw):\n        draw.filled_rect(self.bounding_box, self.colour)\n\n    def update(self, dt):\n        if keyboard.left:\n            self.x -= self.vx * dt\n        if keyboard.right:\n            self.x += self.vx * dt\n\n        # Now keep it in bounds\n        if self.x &lt; self.min_x:\n            self.x = self.min_x\n        elif self.x &gt; self.max_x:\n            self.x = self.max_x\n\n\npaddle = Paddle((WIDTH / 2, HEIGHT - FOOTER_HEIGHT))\n</code></pre> <p>If you run your game now, the paddle will not be displayed and will not respond to keypresses. This is because the paddle has not yet been hooked into the main game loops to call the paddles <code>update()</code> and <code>draw()</code> methods. Add the following <code>update()</code> function.</p> <pre><code>draw_funcs.append(paddle.draw)\nupdate_funcs.append(paddle.update)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below. Pressing the left and right keys will move the paddle left and right.</p> <p></p>"},{"location":"python/pygame/smash/#experiment-changing-the-look-and-speed-of-the-paddle","title":"Experiment: Changing the look and speed of the paddle","text":"<p>Just as the earlier sections allow the look and feel of the game to be changed by modifying values of the UPPERCASE variables, the paddle can be changed too. Experiment with different values for the following variables:</p> <ul> <li><code>PADDLE_COLOUR</code>: This will be a (red, green, blue) triplet.</li> <li><code>PADDLE_WIDTH</code>: 10, 20, 40, 80, 160, 500</li> <li><code>PADDLE_HEIGHT</code>: 1, 3, 6, 10, 20, 50</li> <li><code>PADDLE_SPEED</code>: 0, 100, 200, 400, 1000</li> </ul>"},{"location":"python/pygame/smash/#step-3-adding-the-ball","title":"Step 3: Adding the ball","text":"<p>The completed code for this step is available here.</p> <p>In this step, the ball will be added. Once served, the ball will move itself as well as keep itself within the screen bounds. A Class called <code>Ball</code> will be created to control how the ball behaves. Just like the <code>Paddle</code> Class, <code>Ball</code> will have <code>bounding_box()</code>, <code>draw()</code> and <code>update()</code> methods. <code>Ball</code> also has methods to detect for collisions with itself and for bouncing.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code>BALL_RADIUS = 6\nBALL_COLOUR = (200, 200, 0)\nBALL_SPEED_Y = 500\nBALL_SPIN_X_MIN = 100\nBALL_SPIN_X_MAX = 200\n\nclass Ball:\n\n    def __init__(self, pos):\n        self.position = pos\n        self.vx = 0\n        self.vy = 0\n        self.radius = BALL_RADIUS\n        self.colour = BALL_COLOUR\n        self.min_x = MARGIN_WIDTH + BORDER_WIDTH + BALL_RADIUS\n        self.max_x = WIDTH - MARGIN_WIDTH - BORDER_WIDTH - BALL_RADIUS\n        self.min_y = HEADER_HEIGHT + BORDER_WIDTH + BALL_RADIUS\n        self.max_y = HEIGHT\n\n    @property\n    def bounding_box(self):\n        # Returns the bounding box of the ball\n        x = self.x - self.radius\n        y = self.y - self.radius\n        width = 2 * self.radius\n        height = 2 * self.radius\n        return Rect(x, y, width, height)\n\n    @property\n    def position(self):\n        return self.x, self.y\n\n    @position.setter\n    def position(self, pos):\n        self.x = pos[0]\n        self.y = pos[1]\n\n    def draw(self, draw):\n        draw.filled_circle(self.position, self.radius, self.colour)\n\n    def update(self, dt):\n        # Move the ball and keep it in bounds.\n        self.x += (self.vx * dt)\n        self.y += (self.vy * dt)\n\n        if self.x &lt; self.min_x:\n            self.x = self.min_x\n            self.vx *= -1\n        elif self.x &gt; self.max_x:\n            self.x = self.max_x\n            self.vx *= -1\n\n        if self.y &lt; self.min_y:\n            self.y = self.min_y\n            self.vy *= -1\n        elif self.y &gt; self.max_y:\n            self.y = self.max_y\n            self.vy *= -1\n\n    def stop(self):\n        self.vx = 0\n        self.vy = 0\n\n    def serve(self):\n        self.hit(-BALL_SPEED_Y)\n\n    def bounce(self):\n        self.hit(self.vy * -1)\n\n    def hit(self, vertical_speed):\n        self.vy = vertical_speed\n        spin = random.randint(BALL_SPIN_X_MIN, BALL_SPIN_X_MAX)\n        if keyboard.left:\n            self.vx -= spin\n        else:\n            self.vx += spin\n\n    def collide(self, rect) -&gt; bool:\n        return self.bounding_box.colliderect(rect)\n\n\nball = Ball(paddle.position)\n\ndraw_funcs.append(ball.draw)\nupdate_funcs.append(ball.update)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p>Does the ball move when you move the paddle? Why do you think this might be?</p> <p></p>"},{"location":"python/pygame/smash/#experiment-changing-the-look-and-speed-of-the-ball","title":"Experiment: Changing the look and speed of the ball","text":"<p>Just as the earlier sections allow the look and feel of the game to be changed by modifying values of the UPPERCASE variables, the ball can be changed too. Experiment with different values for the following variables:</p> <ul> <li><code>BALL_RADIUS</code>: 1, 3, 6, 10, 20, 50</li> <li><code>BALL_COLOUR</code>: This will be a (red, green, blue) triplet.</li> </ul>"},{"location":"python/pygame/smash/#step-4-serving-the-ball","title":"Step 4: Serving the ball","text":"<p>The completed code for this step is available here.</p> <p>In this step, we will add the code to serve the ball. This will also include the code which keeps the ball with the paddle before serving.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code>playing = False\nserving = True\ngame_over = False\n\ndef start_game(dt):\n    global score, level, lives, playing, serving, game_over\n\n    if not playing and keyboard.space:\n        score = 0\n        level = 1\n        lives = STARTING_LIVES\n        playing = True\n        serving = True\n        game_over = False\n        setup_blocks()\n\n\ndef serve_ball(dt):\n    global serving, ball\n\n    if serving:\n        # If we are serving, keep the ball with the paddle.\n        ball.position = paddle.position\n\n        # If space is pressed, serve the ball\n        if keyboard.space:\n            serving = False\n            ball.serve()\n\nupdate_funcs.append(start_game)\nupdate_funcs.append(serve_ball)\n</code></pre> <p>Run your game and move the paddle. The ball should move with it. The final step is to add the serving <code>draw()</code> code as follows.</p> <pre><code>def draw_serving(draw):\n    if serving:\n        draw.text(f\"Level {level}\",\n                  center=(WIDTH / 2, HEIGHT / 2),\n                  color=SCORE_COLOUR,\n                  fontsize=72)\n        draw.text(\"Press space to serve\",\n                  center=(WIDTH / 2, HEIGHT * 3 / 4),\n                  color=SCORE_COLOUR,\n                  fontsize=36)\n\ndraw_funcs.append(draw_serving)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p>Does the ball stay with the paddle when you move it left and right?</p> <p>What happens when you press space to serve the ball?</p> <p>You will get an error that starts: <code>Traceback (most recent call last):</code></p> <p>And finishes: <code>NameError: name 'setup_blocks' is not defined</code></p> <p>This is because there are currently no blocks setup in the game. This is what we will do in the next step.</p> <p></p>"},{"location":"python/pygame/smash/#experiment-changing-the-look-of-the-level-and-serving-text","title":"Experiment: Changing the look of the level and serving text","text":"<p>The <code>draw()</code> function is where the text is drawn on the screen. The text is drawn in the same colour as the score. Experiment with changing the colour and size of the two pieces of text to find something you like.</p> <p>You can also experiment with changing the position of the text.</p>"},{"location":"python/pygame/smash/#step-5-adding-blocks","title":"Step 5: Adding blocks","text":"<p>The completed code for this step is available here.</p> <p>In this step we will place the blocks on the screen. As we have done with both the paddle and ball we will create a new Class called 'Block' to represent an individual block. With the <code>Paddle</code> and <code>Ball</code> classes, there was only ever a single instance of each in the game. With <code>Block</code> it will be different as there will be many instances of block. The <code>Block</code> class is a small simple class that just displays itself in a static position. One unique property of a block is that it has a one in five change chance of the <code>Bounce()</code> function returning true. We will make use of this in a later step.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code>class Block:\n\n    def __init__(self, rect, colour, value):\n        self.rect = rect\n        self.colour = colour\n        self.value = value\n\n    @property\n    def bounding_box(self):\n        return self.rect\n\n    @property\n    def bounce(self):\n        return randint(0, 4) == 0\n\n    def draw(self, draw):\n        draw.filled_rect(self.bounding_box, self.colour)\n</code></pre> <p>Because we will always create the blocks in the same positions, we can calculate those positions once at the start of the game and then reuse them. These positions will be stored in the list variable <code>block_rects</code> and calculated in the function <code>setup_block_rects()</code>. The blocks themselves will be stored in a list variable called <code>blocks</code> and those blocks will be created in the function <code>setup_blocks()</code> which will use the values we calculated in <code>block_rects</code>.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code>BLOCK_GAP = 5\nBLOCK_COLUMNS = 10\nBLOCK_HEIGHT = 14\nBLOCK_COLOURS = [\n    (34, 67, 83),\n    (34, 67, 83),\n    (64, 67, 83),\n    (94, 67, 83),\n    (124, 67, 83),\n    (154, 67, 83),\n    (184, 67, 83),\n    (214, 67, 83),\n    (244, 67, 83),\n    (244, 67, 83),\n]\nBLOCK_AREA_WIDTH = WIDTH - (2 * MARGIN_WIDTH) - (2 * BORDER_WIDTH) - BLOCK_GAP\nBLOCK_AREA_LEFT = MARGIN_WIDTH + BORDER_WIDTH + BLOCK_GAP\nBLOCK_AREA_TOP = HEADER_HEIGHT + BORDER_WIDTH + BLOCK_GAP\nBLOCK_AND_GAP_WIDTH = BLOCK_AREA_WIDTH / BLOCK_COLUMNS\nBLOCK_WIDTH = BLOCK_AND_GAP_WIDTH - BLOCK_GAP\nBLOCK_AND_GAP_HEIGHT = BLOCK_HEIGHT + BLOCK_GAP\n\nblock_rects = []\n\ndef setup_block_rects():\n    global block_rects\n\n    for x in range(BLOCK_COLUMNS):\n        block_rects.append([])\n        for y in range(len(BLOCK_COLOURS)):\n            left = BLOCK_AREA_LEFT + (BLOCK_AND_GAP_WIDTH * x)\n            top = BLOCK_AREA_TOP + (BLOCK_AND_GAP_HEIGHT * y)\n            rect = Rect(left, top, BLOCK_WIDTH, BLOCK_HEIGHT)\n            block_rects[x].append(rect)\n\nblocks = []\n\ndef setup_blocks():\n    global blocks\n    blocks = []\n\n    for x in range(len(block_rects)):\n        for y in range(len(block_rects[x])):\n            rect = block_rects[x][y]\n            colour = BLOCK_COLOURS[y]\n            blocks.append(Block(rect, colour, 10 - y))\n\nsetup_block_rects()\nsetup_blocks()\n\ndef draw_blocks(draw):\n    for block in blocks:\n        block.draw(draw)\n\ndraw_funcs.append(draw_blocks)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p>Serve the ball, what happens when the ball hits a block? Why do you think this might be?</p> <p>What happens if the ball misses the paddle? Why do you think that might be?</p> <p></p>"},{"location":"python/pygame/smash/#experiment-changing-the-number-and-look-of-the-blocks","title":"Experiment: Changing the number and look of the blocks","text":"<p>Just as the earlier sections allow the look and feel of the game to be changed by modifying values of the UPPERCASE variables, the number and size of the blocks can be changed too. Experiment with different values for the following variables:</p> <ul> <li><code>BLOCK_GAP</code>: 0, 1, 3, 5, 10, 20</li> <li><code>BLOCK_COLUMNS</code>: 1, 2, 4, 10, 20, 100</li> <li><code>BLOCK_HEIGHT</code>: 1, 2, 5, 10, 14, 30</li> <li><code>BLOCK_COLOURS</code>: : This are all (red, green, blue) triplets.</li> </ul> <p>Also, now the ball moves, experiment with changing the following variables:</p> <ul> <li><code>BALL_SPEED_Y</code>: 100, 300, 1000, 3000</li> <li><code>BALL_SPIN_X_MIN</code>: 0, 50, 100, 200</li> <li><code>BALL_SPIN_X_MAX</code>: 100, 200, 500, 1000</li> </ul>"},{"location":"python/pygame/smash/#step-6-destroying-the-blocks","title":"Step 6: Destroying the blocks","text":"<p>The completed code for this step is available here.</p> <p>In this step, we will get the ball to destroy the blocks. We will write a new function called <code>check_for_collisions()</code> that will do the checking for us as well as updating the players score. Inside this new function a list called <code>blocks_to_destroy</code> is created. That list is created using a very powerful Python technique called a list comprehension. Python list comprehensions are efficient ways to create new lists. The list comprehension in <code>check_for_collisions()</code> creates a new list containing the blocks whose <code>bounding_box</code> collides with the balls <code>bounding_box</code>. For a further explanation of list comprehensions see here.</p> <p>To add a little twist to the game, we don't want the ball to just fly through all of the blocks some blocks until it hits the back wall. We therefore bounce the ball if the block indicates it should bounce.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code>def check_for_collisions(dt):\n    global score, blocks\n\n    if ball.vy &gt; 0 and ball.collide(paddle.bounding_box):\n        ball.bounce()\n\n    blocks_to_destroy = [block for block in blocks if ball.collide(block.bounding_box)]\n    if blocks_to_destroy:\n        for block in blocks_to_destroy:\n            score += block.value\n            blocks.remove(block)\n            if block.bounce:\n                ball.bounce()\n\nupdate_funcs.append(check_for_collisions)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p></p>"},{"location":"python/pygame/smash/#step-7-dropping-the-ball","title":"Step 7: Dropping the ball","text":"<p>The completed code for this step is available here.</p> <p>In the previous step, the ball happily bounces around the screen for ever. The behaviour we want is for the ball the bounce along the bottom only if it makes contact with the paddle. If the ball does not make contact with the paddle, it should be considered dropped and the player loses a life.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code>def check_for_dropping_the_ball(dt):\n    global lives, playing, serving, game_over\n\n    if ball.y &gt; (paddle.y + paddle.height + ball.radius):\n        ball.stop()\n        serving = True\n        lives -= 1\n        if lives &lt;= 0:\n            game_over = True\n            playing = False\n\nupdate_funcs.append(check_for_dropping_the_ball)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p>What happens when you lose all of your lives?</p> <p>To make it easier to clear the blocks, change the number of columns to 2 and comment out some of the colours in the <code>BLOCK_COLOURS</code> variable. What happens when you clear all of the blocks? Why do you think that is?</p> <p></p>"},{"location":"python/pygame/smash/#step-8-levels-and-lives","title":"Step 8: Levels and lives","text":"<p>The completed code for this step is available here.</p> <p>In this step, we will be checking for when the player has cleared all of the blocks and so a new level needs to be started. We will award the player an extra life for each level they clear. We will also add in a \"GAME OVER\" message.</p> <p>Place the following new function before the call to <code>pgzrun.go()</code>.</p> <pre><code>def check_for_new_level(dt):\n    global level, lives, playing, serving, blocks\n\n    if playing and len(blocks) == 0:\n        level += 1\n        lives += 1\n        serving = True\n        setup_blocks()\n\nupdate_funcs.append(check_for_new_level)\n</code></pre> <p>Finally, add the code to draw the \"GAME OVER\" text.</p> <pre><code>def draw_game_over(draw):\n    if game_over:\n        draw.text(\"GAME OVER\",\n                  center=(WIDTH / 2, HEIGHT * 5 / 8),\n                  color=SCORE_COLOUR,\n                  fontsize=72)\n\ndraw_funcs.append(draw_game_over)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p></p>"},{"location":"python/pygame/smash/#experiment-changing-the-look-and-position-of-the-game-over-text","title":"Experiment: Changing the look and position of the GAME OVER text","text":"<p>Experiment with the position, colour and size of the GAME OVER text to find something you like the look of.</p>"},{"location":"python/pygame/smash/#step-9-add-particle-effects","title":"Step 9: Add particle effects","text":"<p>The completed code for this step is available here.</p> <p>In this step, we will be adding some particle effects when the blocks gets destroyed. Each particle effect will only last for a few seconds and is designed to add visual interest to the game. all the particle effects will have gravity applied to them which will make them tend towards the bottom of the screen over time. Two particle effects will be added:</p> <ul> <li><code>ParticleScore</code>: This will be a single particle containing the score value of the block destroyed.   It will slowly fall towards the ground.</li> <li><code>ParticleExplosion</code>:  This will generate a preset number of dots in the colour of the block that   are spread in random directions from the centre of the block before slowly falling towards the ground.</li> </ul> <p>As well as the usual <code>update()</code> and <code>draw()</code> methods, all particle effects need an <code>alive</code> property which will return <code>True</code> is the particle effect is still running or <code>False</code> is the particle effect has completed. This property will be used by the game engine to remove completed particle effects.</p>"},{"location":"python/pygame/smash/#score-particle-effect","title":"Score particle effect","text":"<p>The first particle effect we will add is <code>ParticleScore</code>. We will also add the <code>GRAVITY</code> and <code>particles</code> variables. The <code>GRAVITY</code> variable represent the gravity which applies to the particles (in pixels per second). The <code>particles</code> list variable holds all particles effects currently operating. The <code>ParticleScore</code> Class will draw just a single number. The direction that the effect will take is chosen randomly (from a defined range) when an instance of <code>ParticleScore</code> if created.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code>GRAVITY = 60\n\nparticles = []\n\nPARTICLE_SCORE_MIN_VX = -60\nPARTICLE_SCORE_MAX_VX = 60\nPARTICLE_SCORE_MIN_VY = -30\nPARTICLE_SCORE_MAX_VY = 60\n\n\nclass ParticleScore:\n\n    def __init__(self, pos, lifetime, value):\n        self.position = pos\n        self.left = lifetime\n        self.value = value\n        self.vx = randint(PARTICLE_SCORE_MIN_VX, PARTICLE_SCORE_MAX_VX)\n        self.vy = randint(PARTICLE_SCORE_MIN_VY, PARTICLE_SCORE_MAX_VY)\n\n    @property\n    def position(self):\n        return self.x, self.y\n\n    @position.setter\n    def position(self, pos):\n        self.x = pos[0]\n        self.y = pos[1]\n\n    @property\n    def alive(self):\n        return self.left &gt; 0\n\n    def draw(self, draw):\n        draw.text(f\"{self.value}\",\n                     center=self.position,\n                     color=SCORE_COLOUR,\n                     fontsize=24)\n\n    def update(self, dt):\n        self.left -= dt\n        self.vy += (GRAVITY * dt)\n        self.x += self.vx * dt\n        self.y += self.vy * dt\n</code></pre>"},{"location":"python/pygame/smash/#explosion-particle-effect","title":"Explosion particle effect","text":"<p>The second particle effect that is to be added is <code>PartcleExplosion</code>. Whereas <code>ParticleScore</code> displayed a single number, <code>ParticleExplosion</code> will display lots of pixels (configured by the <code>PARTICLE_EXPLOSION_PARTICLES</code> variable). <code>ParticleExplosion</code> is a little more complicated than <code>ParticleScore</code> due to having multiple pixels; though you have seen all coding techniques used here in previous steps. Of particular note is the use of a list comprehension  in the <code>update()</code> method. For a further explanation of list comprehensions see here.</p> <p>Place the following code below <code>ParticleScore</code>.</p> <pre><code>PARTICLE_EXPLOSION_MIN_VX = -90\nPARTICLE_EXPLOSION_MAX_VX = 90\nPARTICLE_EXPLOSION_MIN_VY = -90\nPARTICLE_EXPLOSION_MAX_VY = 90\nPARTICLE_EXPLOSION_PARTICLES = 30\n\n\nclass ParticleExplosion:\n\n    def __init__(self, pos, lifetime, colour):\n        self.left = lifetime\n        self.colour = colour\n        self.particles = [(pos[0], pos[1],\n                           randint(PARTICLE_EXPLOSION_MIN_VX,\n                                   PARTICLE_EXPLOSION_MAX_VX),\n                           randint(PARTICLE_EXPLOSION_MIN_VY,\n                                   PARTICLE_EXPLOSION_MAX_VY))\n                          for _ in range(PARTICLE_EXPLOSION_PARTICLES)]\n\n    @property\n    def alive(self):\n        return self.left &gt; 0\n\n    def draw(self, draw):\n        for particle in self.particles:\n            draw.filled_circle((particle[0], particle[1]), 1, self.colour)\n\n    def update(self, dt):\n        self.left -= dt\n\n        self.particles = [(particle[0] + (particle[2] * dt),\n                           particle[1] + (particle[3] * dt), particle[2],\n                           particle[3] + (GRAVITY * dt))\n                          for particle in self.particles]\n</code></pre>"},{"location":"python/pygame/smash/#hooking-the-particle-effects-in","title":"Hooking the particle effects in","text":"<p>For the particle effects to be added to the game engine, a small change needs to be made to the <code>check_for_collisions()</code> method to add the effects when a block is destroyed. The two lines of code that need to be added are given below. The values 2 and 4 represent the lifetime (think duration) that each partcile effect will last for.</p> <pre><code>particles.append(ParticleScore(block.rect.center, 2, block.value))\nparticles.append(ParticleExplosion(block.rect.center, 4, block.colour))\n</code></pre> <p>Add those two lines of code to the <code>check_for_collisions()</code> function. The function <code>check_for_collisions()</code> should now look like this:</p> <pre><code>def check_for_collisions(dt):\n    global score, blocks\n\n    blocks_to_destroy = [\n        block for block in blocks if ball.collide(block.bounding_box)\n    ]\n    if blocks_to_destroy:\n        for block in blocks_to_destroy:\n            score += block.value\n            blocks.remove(block)\n            if block.bounce:\n                ball.bounce()\n\n            particles.append(ParticleScore(block.rect.center, 2, block.value))\n            particles.append(ParticleExplosion(block.rect.center, 4, block.colour))                \n</code></pre> <p>All that remains now is to update and draw the particles. Place the following code before the call to <code>pgzrun.go()</code>. </p> <pre><code>def update_particles(dt):\n    global particles\n    for particle in particles:\n        particle.update(dt)\n\n    particles = [particle for particle in particles if particle.alive]\n\nupdate_funcs.append(update_particles)\n\ndef draw_particles(draw):\n    for particle in particles:\n        particle.draw(draw)\n\ndraw_funcs.append(draw_particles)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p></p>"},{"location":"python/pygame/smash/#experiment-changing-the-particles","title":"Experiment: Changing the particles","text":"<p>Experiment with changing the lifetimes of the particles. Unlike previous settings, the lifetimes are not set through UPPERCASE variables. The lifetimes of the particles are set in the <code>check_for_collisions()</code> function. See if you can find the values. Try values from 1 through to 10 to see what effect it has.</p> <p>There are other aspects of the PARTICLES that can be changed by modifying values of UPPERCASE variables. The <code>GRAVITY</code> variable affects both particle effects but the other variables affect only one of them. Experiment with different values for the following variables:</p> <ul> <li> <p><code>GRAVITY</code>: 0, 10, 30, 60, 100, 200</p> </li> <li> <p><code>PARTICLE_SCORE_MIN_VX</code>: -200, -100, -60, 0, 60</p> </li> <li><code>PARTICLE_SCORE_MAX_VX</code>: -30, 0, 30, 60, 100, 200, 1000</li> <li><code>PARTICLE_SCORE_MIN_VY</code>: -200, -100, -60, -30, 0, 60</li> <li> <p><code>PARTICLE_SCORE_MAX_VY</code>: -30, 0, 30, 60, 100, 200, 1000</p> </li> <li> <p><code>PARTICLE_EXPLOSION_MIN_VX</code>: -200, -90, -60, 0, 60</p> </li> <li><code>PARTICLE_EXPLOSION_MAX_VX</code>: -30, 0, 30, 60, 90, 200, 1000</li> <li><code>PARTICLE_EXPLOSION_MIN_VY</code>: -200, -90, -60, -30, 0, 60</li> <li><code>PARTICLE_EXPLOSION_MAX_VY</code>: -30, 0, 30, 60, 90, 200, 1000</li> <li><code>PARTICLE_EXPLOSION_PARTICLES</code>: 1, 5, 30, 100, 1000</li> </ul>"},{"location":"python/pygame/smash/#extension-add-your-own-particle-effects","title":"Extension: Add your own particle effects","text":"<p>Try adding your own particle effect. Using the <code>ParticleScore</code> as your template, design a particle effect that writes a randomly selected word from a list. The following code snippet is one way to randomly select a word from a list:</p> <pre><code>word = random.choice([\"boom\", \"bang\", \"crash\", \"wallop\"])\n</code></pre>"},{"location":"python/pygame/smash/#step-10-dropping-bonuses","title":"Step 10: Dropping bonuses","text":"<p>The completed code for this step is available here.</p> <p>In this step, we will be adding bonuses that randomly get dropped when a block is destroyed. The steps to add bonuses to the game are very similar to those that were used to add particles. The primary difference between bonuses and particles is the bonuses float to the bottom of the screen where they can be collected by the paddle. If the bonuses are dropped then they are lost. There particle effects will be added:</p> <ul> <li><code>BonusLives</code>: If collected, the player will be awarded between 1 and 3 extra lives</li> <li><code>BonusPaddle</code>: If collected, the paddle will double in size for a short period.</li> <li><code>BonusSpeed</code>: If collected, the vertical speed of the ball will be reduced for a short period.</li> </ul> <p>As well as the usual <code>update()</code> and <code>draw()</code> methods, all bonuses need an <code>alive</code> property which will return <code>True</code> is the bonus has not been caught and is still on the screen or <code>False</code> otherwise. This property will be used by the game engine to remove caught or dropped bonuses.</p> <p>In addition, each bonus needs a <code>catch()</code> method which is called when the paddle makes contact with the bonus. The <code>catch()</code> method allows the bonus to perform the appropriate action such as give the player more lives, make the paddle bigger or slow the ball down.</p>"},{"location":"python/pygame/smash/#extra-lives-bonus","title":"Extra lives bonus","text":"<p>The first bonus effect is <code>BonusLives</code>. When created it will randomly choose how many lives to award the player if caught.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code>BLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\n\nBONUS_WIDTH = 60\nBONUS_HEIGHT = 40\n\nbonuses = []\n\n\nclass BonusLives:\n\n    def __init__(self, rect):\n        self.rect = copy(rect)\n        self.caught = False\n        self.lives = randint(1, 3)\n\n    @property\n    def bounding_box(self):\n        return self.rect\n\n    @property\n    def alive(self):\n        return not self.caught and self.rect.y &lt; HEIGHT\n\n    def draw(self, draw):\n        draw.filled_rect(self.bounding_box, WHITE)\n        draw.text(f\"lives x{self.lives}\",\n                  center=self.bounding_box.center,\n                  color=BLACK,\n                  fontsize=20)\n\n    def update(self, dt):\n        self.rect.y += GRAVITY * 4 * dt\n\n    def catch(self):\n        global lives\n        lives += self.lives\n        self.caught = True\n</code></pre>"},{"location":"python/pygame/smash/#larger-paddle-bonus","title":"Larger paddle bonus","text":"<p>The second bonus effect is <code>BonusPaddle</code>. This will make the paddle twice as wide as usual for a short period of time. The duration the paddle is bigger is randomly selected between 5 and 10 seconds in the <code>catch()</code> method.</p> <p>Place the following code below <code>BonusLives</code>.</p> <pre><code>def reset_paddle():\n    paddle.width = PADDLE_WIDTH\n\n\nclass BonusPaddle:\n\n    def __init__(self, rect):\n        self.rect = copy(rect)\n        self.caught = False\n\n    @property\n    def bounding_box(self):\n        return self.rect\n\n    @property\n    def alive(self):\n        return not self.caught and self.rect.y &lt; HEIGHT\n\n    def draw(self, draw):\n        draw.filled_rect(self.bounding_box, WHITE)\n        draw.text(f\"paddle\",\n                  center=self.bounding_box.center,\n                  color=BLACK,\n                  fontsize=20)\n\n    def update(self, dt):\n        self.rect.y += GRAVITY * 4 * dt\n\n    def catch(self):\n        paddle.width = PADDLE_WIDTH * 2\n        clock.schedule_unique(reset_paddle, randint(5, 10))\n        self.caught = True\n</code></pre>"},{"location":"python/pygame/smash/#slower-ball-bonus","title":"Slower ball bonus","text":"<p>The third bonus effect is <code>BonusSpeed</code>. This will make the balls vertical speed slower for a short period of time. The duration the ball is slowwer is randomly selected between 10 and 20 seconds in the <code>catch()</code> method.</p> <p>Place the following code below <code>BonusPaddle</code>.</p> <pre><code>def reset_ball():\n    if ball.vy &gt; 0:\n        ball.vy = BALL_SPEED_Y\n    else:\n        ball.vy = -BALL_SPEED_Y\n\n\nclass BonusSpeed:\n\n    def __init__(self, rect):\n        self.rect = copy(rect)\n        self.caught = False\n\n    @property\n    def bounding_box(self):\n        return self.rect\n\n    @property\n    def alive(self):\n        return not self.caught and self.rect.y &lt; HEIGHT\n\n    def draw(self, draw):\n        draw.filled_rect(self.bounding_box, WHITE)\n        draw.text(f\"speed\",\n                  center=self.bounding_box.center,\n                  color=BLACK,\n                  fontsize=20)\n\n    def update(self, dt):\n        self.rect.y += GRAVITY * 4 * dt\n\n    def catch(self):\n        if ball.vy &gt; 0:\n            ball.vy = BALL_SPEED_Y / 4\n        else:\n            ball.vy = -BALL_SPEED_Y / 4\n\n        clock.schedule_unique(reset_ball, randint(10, 20))\n        self.caught = True\n</code></pre>"},{"location":"python/pygame/smash/#connecting-it-all-up","title":"Connecting it all up","text":"<p>Update the <code>check_for_collisions()</code> function by adding code to the end of it that both checks for collisions with the bonuses and decides if a new bonus should be dropped or not. Only one bonus is allowed to drop at any time and there is a 1 in 10 change of a bonus being granted. Your <code>check_for_collisions()</code> function should now look like the following.</p> <pre><code>def check_for_collisions(dt):\n    global score, blocks\n\n    blocks_to_destroy = [block for block in blocks if ball.collide(block.bounding_box)]\n    if blocks_to_destroy:\n        for block in blocks_to_destroy:\n            score += block.value\n            block.destroy()\n            blocks.remove(block)\n            if block.bounce:\n                ball.bounce()\n\n    global bonuses\n\n    for bonus in bonuses:\n        if bonus.alive and bonus.bounding_box.colliderect(paddle.bounding_box):\n            bonus.catch()\n\n    if len(blocks_to_destroy) &gt; 0 and len(bonuses) == 0 and randint(0, 9) == 0:\n\n        bounding_box = copy(blocks_to_destroy[0].bounding_box)\n\n        choice = randint(0, 2)\n        if choice == 0:\n            bonuses.append(BonusLives(bounding_box))\n        elif choice == 1:\n            bonuses.append(BonusPaddle(bounding_box))\n        else:\n            bonuses.append(BonusSpeed(bounding_box))\n</code></pre> <p>All that remains now is to update and draw the bonuses.</p> <pre><code>def update_bonuses(dt):\n    global bonuses\n\n    for bonus in bonuses:\n        bonus.update(dt)\n\n    bonuses = [bonus for bonus in bonuses if bonus.alive]\n\nupdate_funcs.append(update_bonuses)\n\ndef draw_bonuses(draw):\n    for bonus in bonuses:\n        bonus.draw(draw)\n\ndraw_funcs.append(draw_bonuses)\n</code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p></p>"},{"location":"python/pygame/smash/#experiment-changing-how-often-bonuses-are-dropped","title":"Experiment: Changing how often bonuses are dropped","text":"<p>Increase the number on bonuses that can be dropped at any one time from 1 to 2.</p> <p>Increase how often bonuses get dropped from 1 in 10 to 1 in 5.</p> <p>Change the minimum and maximum number of lives that can be awarded by <code>BonusLives</code>. Set the minimum to 3 and maximum to 6.</p> <p>Change the duration that the <code>BonusPaddle</code> and <code>BonusBall</code> bonuses last.</p>"},{"location":"python/pygame/smash/#step-11-adding-sound-effects","title":"Step 11: Adding sound effects","text":"<p>The completed code for this step is available here.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code></code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p></p>"},{"location":"python/pygame/smash/#step-12-background-music","title":"Step 12: Background music","text":"<p>The completed code for this step is available here.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code></code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p></p>"},{"location":"python/pygame/smash/#step-13-different-levels","title":"Step 13: Different levels","text":"<p>The completed code for this step is available here.</p> <p>Place the following code before the call to <code>pgzrun.go()</code>.</p> <pre><code></code></pre> <p>Run your game and make sure it works; it should look like the screen shot below.</p> <p></p>"},{"location":"python/pygame/smash/#appendix-a-finished-code","title":"Appendix A: Finished code","text":""}]}